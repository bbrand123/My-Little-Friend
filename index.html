<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pet Care Buddy - Virtual Pet Game for Kids</title>
    <style>
        /* CSS Reset and Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            /* Bright, cheerful color palette with high contrast */
            --color-bg: #FFF8E7;
            --color-primary: #FF6B6B;
            --color-secondary: #4ECDC4;
            --color-accent: #FFE66D;
            --color-happy: #95E86F;
            --color-neutral: #FFB347;
            --color-sad: #FF6B6B;
            --color-text: #2D3436;
            --color-text-light: #FFFFFF;
            --color-button-feed: #FF8C42;
            --color-button-wash: #4FC3F7;
            --color-button-play: #AED581;
            --color-button-sleep: #9575CD;
            --color-button-medicine: #F48FB1;
            --color-button-groom: #CE93D8;
            --color-button-exercise: #FFB74D;
            --color-button-treat: #FF7EB3;
            --color-button-pet: #FFB4A2;
            --color-hunger: #FF7043;
            --color-clean: #29B6F6;
            --color-happy-bar: #66BB6A;
            --color-energy: #FFD54F;
            --shadow: 0 4px 15px rgba(0,0,0,0.15);
            --radius: 20px;
            --focus-outline: 4px solid #6C63FF;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard', 'Arial Rounded MT Bold', sans-serif;
            background: linear-gradient(135deg, var(--color-bg) 0%, #FFE4E1 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--color-text);
            line-height: 1.4;
        }

        /* Skip link for keyboard users */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--color-primary);
            color: white;
            padding: 10px 20px;
            z-index: 100;
            border-radius: 0 0 10px 0;
            font-weight: bold;
            text-decoration: none;
        }

        .skip-link:focus {
            top: 0;
            outline: var(--focus-outline);
        }

        /* Focus styles for accessibility */
        *:focus {
            outline: var(--focus-outline);
            outline-offset: 3px;
        }

        *:focus:not(:focus-visible) {
            outline: none;
        }

        *:focus-visible {
            outline: var(--focus-outline);
            outline-offset: 3px;
        }

        /* Main Game Container */
        .game-container {
            background: white;
            border-radius: var(--radius);
            box-shadow: 0 8px 32px rgba(0,0,0,0.12), 0 2px 8px rgba(0,0,0,0.08);
            padding: 20px;
            max-width: 500px;
            width: 100%;
            text-align: center;
            border: 2px solid rgba(255, 107, 107, 0.15);
        }

        /* Header */
        .game-header {
            margin-bottom: 10px;
        }

        .game-title {
            font-size: 1.8rem;
            color: var(--color-primary);
            text-shadow: 2px 2px 0 var(--color-accent);
            margin-bottom: 5px;
            letter-spacing: 0.02em;
        }

        .game-title::after {
            content: '';
            display: block;
            width: 60px;
            height: 3px;
            background: linear-gradient(90deg, var(--color-primary), var(--color-accent), var(--color-secondary));
            border-radius: 3px;
            margin: 6px auto 0;
        }

        /* Pet Display Area */
        .pet-area {
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
            border-radius: var(--radius);
            padding: 20px 20px 25px;
            margin: 8px 0;
            min-height: 220px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            transition: background 2s ease;
        }

        /* Ground with grass texture */
        .pet-area::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35px;
            background: linear-gradient(180deg, #7CB342 0%, #558B2F 100%);
            border-radius: 0 0 var(--radius) var(--radius);
        }

        .pet-area::before {
            content: 'üå∏ üåº üå∑';
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            font-size: 0.7rem;
            letter-spacing: 16px;
            text-align: center;
            z-index: 1;
            pointer-events: none;
            opacity: 0.8;
        }

        .pet-area.nighttime::before {
            content: 'üåø üçÉ üåø';
            opacity: 0.4;
        }

        /* Hide default ::before decor when room system is active */
        .pet-area[class*="room-"]::before {
            content: '';
            display: none;
        }

        /* Floating clouds */
        .cloud {
            position: absolute;
            z-index: 0;
            opacity: 0.7;
            font-size: 1.6rem;
            animation: cloudDrift 20s linear infinite;
            pointer-events: none;
        }

        .cloud:nth-child(2) {
            animation-duration: 28s;
            animation-delay: -8s;
            font-size: 1.2rem;
            opacity: 0.5;
        }

        @keyframes cloudDrift {
            0% { transform: translateX(-40px); }
            100% { transform: translateX(calc(100% + 40px)); }
        }

        /* Pet Container */
        .pet-container {
            position: relative;
            z-index: 1;
            transition: transform 0.3s ease;
        }

        .pet-container.bounce {
            animation: bounce 0.5s ease;
        }

        .pet-container.wiggle {
            animation: wiggle 0.5s ease;
        }

        .pet-container.sparkle {
            animation: sparkle 0.6s ease;
        }

        .pet-container.sleep-anim {
            animation: sleepBob 0.8s ease;
        }

        .pet-container.groom-anim {
            animation: groomPreen 0.8s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-30px); }
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg); }
            75% { transform: rotate(10deg); }
        }

        @keyframes sparkle {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.3); }
        }

        @keyframes sleepBob {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-5px) rotate(-3deg); }
            75% { transform: translateY(-5px) rotate(3deg); }
        }

        @keyframes groomPreen {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.05) rotate(-5deg); }
            50% { transform: scale(1.08) rotate(0deg); }
            75% { transform: scale(1.05) rotate(5deg); }
        }

        .pet-container.treat-anim {
            animation: treatBounce 0.8s ease;
        }

        @keyframes treatBounce {
            0%, 100% { transform: scale(1) translateY(0); }
            30% { transform: scale(1.1) translateY(-15px); }
            50% { transform: scale(1.05) translateY(-5px); }
            70% { transform: scale(1.12) translateY(-10px); }
        }

        .pet-container.cuddle-anim {
            animation: cuddleNuzzle 0.8s ease;
        }

        @keyframes cuddleNuzzle {
            0%, 100% { transform: scale(1) rotate(0deg); }
            15% { transform: scale(1.08) rotate(-3deg); }
            30% { transform: scale(1.12) rotate(2deg); }
            45% { transform: scale(1.1) rotate(-2deg); }
            60% { transform: scale(1.12) rotate(1deg); }
            75% { transform: scale(1.08) rotate(-1deg); }
        }

        .pet-container.exercise-anim {
            animation: exerciseRun 0.8s ease;
        }

        @keyframes exerciseRun {
            0% { transform: translateX(0); }
            20% { transform: translateX(-15px) translateY(-5px); }
            40% { transform: translateX(15px) translateY(-8px); }
            60% { transform: translateX(-10px) translateY(-3px); }
            80% { transform: translateX(10px) translateY(-5px); }
            100% { transform: translateX(0); }
        }

        /* Pet SVG Styles */
        .pet-svg {
            width: 150px;
            height: 150px;
            transition: all 0.3s ease;
        }

        /* Egg Styles */
        .egg-container {
            cursor: pointer;
            transition: transform 0.1s ease;
            background: transparent;
            border: none;
            padding: 10px;
            border-radius: 20px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .egg-container:hover,
        .egg-container:focus {
            transform: scale(1.05);
            background: rgba(255,255,255,0.2);
        }

        .egg-container:active {
            transform: scale(0.95);
        }

        .egg-svg {
            width: 120px;
            height: 160px;
        }

        .egg-crack {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .egg-shake {
            animation: eggShake 0.3s ease;
        }

        @keyframes eggShake {
            0%, 100% { transform: rotate(0deg); }
            20% { transform: rotate(-5deg); }
            40% { transform: rotate(5deg); }
            60% { transform: rotate(-5deg); }
            80% { transform: rotate(5deg); }
        }

        .hatch-message {
            font-size: 1.5rem;
            color: var(--color-text);
            margin-top: 15px;
            font-weight: bold;
        }

        .tap-hint {
            font-size: 1.2rem;
            color: var(--color-text);
            margin-top: 10px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* Egg progress dots */
        .egg-progress {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 12px;
        }

        .egg-progress-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(0,0,0,0.1);
            border: 2px solid rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .egg-progress-dot.filled {
            background: var(--color-accent);
            border-color: #F5C518;
            box-shadow: 0 0 6px rgba(255, 230, 109, 0.6);
            transform: scale(1.15);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Pet Name Display */
        .pet-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            z-index: 2;
        }

        .pet-name {
            font-size: 1.4rem;
            color: var(--color-primary);
            font-weight: bold;
            margin-top: 8px;
            text-shadow: 1px 1px 0 var(--color-accent);
        }

        .mood-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-top: 6px;
            letter-spacing: 0.03em;
        }

        .mood-badge.happy {
            background: rgba(149, 232, 111, 0.25);
            color: #4CAF50;
            border: 1.5px solid rgba(149, 232, 111, 0.5);
        }

        .mood-badge.neutral {
            background: rgba(255, 179, 71, 0.25);
            color: #F57C00;
            border: 1.5px solid rgba(255, 179, 71, 0.5);
        }

        .mood-badge.sad {
            background: rgba(255, 107, 107, 0.25);
            color: #E53935;
            border: 1.5px solid rgba(255, 107, 107, 0.5);
        }

        .mood-badge.sleepy {
            background: rgba(130, 120, 200, 0.25);
            color: #5C4DB1;
            border: 1.5px solid rgba(130, 120, 200, 0.5);
        }

        .mood-badge.energetic {
            background: rgba(255, 215, 0, 0.25);
            color: #F9A825;
            border: 1.5px solid rgba(255, 215, 0, 0.5);
        }

        .mood-badge-emoji {
            font-size: 0.85rem;
        }

        .pet-mood {
            font-size: 0.95rem;
            color: var(--color-text);
            margin-top: 2px;
            z-index: 2;
            position: relative;
        }

        /* Needs Section - Compact Circular Indicators */
        .needs-section {
            margin: 10px 0 5px;
            padding-bottom: 14px;
        }

        .needs-row {
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .need-bubble {
            position: relative;
            width: 58px;
            height: 58px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            transition: transform 0.2s ease;
        }

        .need-bubble:hover {
            transform: scale(1.1);
        }

        .need-bubble-ring {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: conic-gradient(var(--ring-color) calc(var(--progress) * 1%), #e0e0e0 0);
            mask: radial-gradient(farthest-side, transparent calc(100% - 5px), #fff calc(100% - 4.5px));
            -webkit-mask: radial-gradient(farthest-side, transparent calc(100% - 5px), #fff calc(100% - 4.5px));
            transition: background 0.5s ease;
        }

        .need-bubble-icon {
            font-size: 1.5rem;
            z-index: 1;
            line-height: 1;
        }

        .need-bubble-value {
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            font-weight: bold;
            color: var(--color-text);
            white-space: nowrap;
        }

        .need-bubble-label {
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.58rem;
            color: #999;
            white-space: nowrap;
            font-weight: 700;
            letter-spacing: 0.03em;
            text-transform: uppercase;
        }

        .need-bubble.low .need-bubble-icon {
            animation: needPulse 1.5s ease-in-out infinite;
        }

        @keyframes needPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        /* Action Buttons - Horizontal Scrolling Strip */
        .actions-section {
            margin-top: 10px;
        }

        .action-scroll {
            display: flex;
            gap: 10px;
            padding: 8px 4px 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .action-btn {
            min-width: 68px;
            min-height: 68px;
            width: 68px;
            height: 68px;
            flex-shrink: 0;
            border: none;
            border-radius: 18px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3px;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.18);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            font-family: inherit;
        }

        .action-btn:hover,
        .action-btn:focus {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 5px 12px rgba(0,0,0,0.25);
        }

        .action-btn:active {
            transform: translateY(0) scale(0.97);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .action-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .action-btn.cooldown {
            pointer-events: none;
            opacity: 0.7;
        }

        .action-btn.feed {
            background: linear-gradient(135deg, var(--color-button-feed), #F57C00);
        }

        .action-btn.wash {
            background: linear-gradient(135deg, var(--color-button-wash), #0288D1);
        }

        .action-btn.play {
            background: linear-gradient(135deg, var(--color-button-play), #7CB342);
        }

        .action-btn.sleep {
            background: linear-gradient(135deg, var(--color-button-sleep), #7E57C2);
        }

        .action-btn.medicine {
            background: linear-gradient(135deg, var(--color-button-medicine), #EC407A);
        }

        .action-btn.groom {
            background: linear-gradient(135deg, var(--color-button-groom), #AB47BC);
        }

        .action-btn.exercise {
            background: linear-gradient(135deg, var(--color-button-exercise), #FF9800);
        }

        .action-btn.treat {
            background: linear-gradient(135deg, var(--color-button-treat), #FF4081);
        }

        .action-btn.pet-cuddle {
            background: linear-gradient(135deg, var(--color-button-pet), #E88B73);
        }

        .btn-icon {
            font-size: 1.6rem;
            line-height: 1;
        }

        /* Feedback Messages */
        .feedback-area {
            min-height: 28px;
            margin: 6px 0 4px;
        }

        .feedback-message {
            font-size: 1.1rem;
            color: var(--color-happy);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
            animation: feedbackPop 0.5s ease;
        }

        .feedback-message.show {
            opacity: 1;
        }

        @keyframes feedbackPop {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* New Pet Button - subtle to reduce accidental clicks */
        .new-pet-btn {
            margin-top: 12px;
            padding: 8px 18px;
            font-size: 0.75rem;
            background: transparent;
            color: #999;
            border: 1.5px dashed #ccc;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .new-pet-btn:hover,
        .new-pet-btn:focus {
            color: #7B1FA2;
            border-color: #9C27B0;
            background: rgba(156, 39, 176, 0.06);
            transform: translateY(-1px);
        }

        /* Screen Reader Only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Live Region for Screen Readers */
        .live-region {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Sparkle Effect */
        .sparkles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .sparkle-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--color-accent);
            border-radius: 50%;
            animation: sparkleFloat 1s ease-out forwards;
        }

        @keyframes sparkleFloat {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0) translateY(-50px);
            }
        }

        /* Hearts for Play */
        .heart-particle {
            position: absolute;
            font-size: 1.5rem;
            animation: heartFloat 1s ease-out forwards;
        }

        @keyframes heartFloat {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(1.5) translateY(-60px);
            }
        }

        /* Bubbles for Wash */
        .bubble-particle {
            position: absolute;
            width: 15px;
            height: 15px;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            border: 2px solid rgba(100,200,255,0.5);
            animation: bubbleFloat 1.2s ease-out forwards;
        }

        @keyframes bubbleFloat {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translateY(-70px);
            }
        }

        /* Zzz particles for Sleep */
        .zzz-particle {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            color: #9575CD;
            animation: zzzFloat 1.5s ease-out forwards;
        }

        @keyframes zzzFloat {
            0% {
                opacity: 1;
                transform: scale(0.5) translateY(0) translateX(0);
            }
            50% {
                opacity: 1;
                transform: scale(1) translateY(-30px) translateX(10px);
            }
            100% {
                opacity: 0;
                transform: scale(1.2) translateY(-60px) translateX(20px);
            }
        }

        /* Star particles for Sleep */
        .star-particle {
            position: absolute;
            font-size: 1.2rem;
            animation: starTwinkle 1.2s ease-out forwards;
        }

        @keyframes starTwinkle {
            0% {
                opacity: 0;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) rotate(360deg);
            }
        }

        /* Medicine healing particles */
        .medicine-particle {
            position: absolute;
            font-size: 1.3rem;
            animation: medicineFloat 1.3s ease-out forwards;
        }

        @keyframes medicineFloat {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(0);
            }
            30% {
                opacity: 1;
                transform: scale(1.2) translateY(-20px);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-50px);
            }
        }

        .pet-container.heal-anim {
            animation: healPulse 0.8s ease;
        }

        @keyframes healPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            25% { transform: scale(1.05); filter: brightness(1.1) hue-rotate(10deg); }
            50% { transform: scale(1.08); filter: brightness(1.2) hue-rotate(0deg); }
            75% { transform: scale(1.05); filter: brightness(1.1) hue-rotate(-10deg); }
        }

        /* Grooming particles */
        .groom-particle {
            position: absolute;
            font-size: 1.3rem;
            animation: groomFloat 1.3s ease-out forwards;
        }

        @keyframes groomFloat {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(0) rotate(0deg);
            }
            30% {
                opacity: 1;
                transform: scale(1.2) translateY(-15px) rotate(10deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-45px) rotate(-10deg);
            }
        }

        .exercise-particle {
            position: absolute;
            font-size: 1.3rem;
            animation: exerciseFloat 1.3s ease-out forwards;
        }

        @keyframes exerciseFloat {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(0) translateX(0);
            }
            30% {
                opacity: 1;
                transform: scale(1.2) translateY(-10px) translateX(10px);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-40px) translateX(-15px);
            }
        }

        /* Treat particles */
        .treat-particle {
            position: absolute;
            font-size: 1.4rem;
            animation: treatFloat 1.4s ease-out forwards;
        }

        @keyframes treatFloat {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(0) rotate(0deg);
            }
            25% {
                opacity: 1;
                transform: scale(1.3) translateY(-15px) rotate(15deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.6) translateY(-55px) rotate(-15deg);
            }
        }

        /* Cuddle/petting particles */
        .cuddle-particle {
            position: absolute;
            font-size: 1.4rem;
            animation: cuddleFloat 1.4s ease-out forwards;
        }

        @keyframes cuddleFloat {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(0) rotate(0deg);
            }
            20% {
                opacity: 1;
                transform: scale(1.2) translateY(-10px) rotate(-10deg);
            }
            50% {
                opacity: 1;
                transform: scale(1.4) translateY(-25px) rotate(5deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-55px) rotate(-5deg);
            }
        }

        /* Pettable pet area cursor */
        .pet-container.pettable {
            cursor: pointer;
        }

        .pet-container.pettable:hover {
            filter: brightness(1.05);
        }

        /* Day/Night cycle styles */
        .pet-area.daytime {
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
        }

        .pet-area.sunset {
            background: linear-gradient(180deg, #FF7E5F 0%, #FEB47B 50%, #98FB98 100%);
        }

        .pet-area.nighttime {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }

        .pet-area.nighttime::after {
            background: linear-gradient(180deg, #2d4a22 0%, #1a3015 100%);
        }

        .pet-area.sunrise {
            background: linear-gradient(180deg, #ffecd2 0%, #fcb69f 50%, #98FB98 100%);
        }

        /* ==================== ROOM NAVIGATION ==================== */

        .room-nav {
            display: flex;
            gap: 6px;
            justify-content: center;
            padding: 8px 4px;
            margin: 4px 0;
            flex-wrap: wrap;
        }

        .room-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 6px 10px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: 12px;
            background: rgba(255,255,255,0.85);
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            min-width: 56px;
        }

        .room-btn:hover, .room-btn:focus-visible {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
            border-color: var(--primary);
        }

        .room-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: 0 2px 8px rgba(108, 99, 255, 0.4);
        }

        .room-btn-icon {
            font-size: 1.3rem;
            line-height: 1;
        }

        .room-btn-label {
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Room-specific ground styles */
        .pet-area.room-bedroom::after {
            background: linear-gradient(180deg, #8D6E63 0%, #6D4C41 100%);
        }
        .pet-area.room-kitchen::after {
            background: linear-gradient(180deg, #BDBDBD 0%, #9E9E9E 100%);
        }
        .pet-area.room-bathroom::after {
            background: linear-gradient(180deg, #80DEEA 0%, #4DD0E1 100%);
        }
        .pet-area.room-backyard::after {
            background: linear-gradient(180deg, #7CB342 0%, #558B2F 100%);
        }
        .pet-area.room-park::after {
            background: linear-gradient(180deg, #66BB6A 0%, #43A047 100%);
        }

        /* Room-specific decor */
        .room-decor {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            font-size: 0.7rem;
            letter-spacing: 16px;
            text-align: center;
            z-index: 1;
            pointer-events: none;
            opacity: 0.8;
        }

        /* Room label */
        .room-label {
            position: absolute;
            top: 8px;
            left: 12px;
            background: rgba(255,255,255,0.7);
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
            z-index: 2;
            pointer-events: none;
        }

        .pet-area.nighttime .room-label {
            background: rgba(0,0,0,0.4);
            color: #E0E0E0;
        }

        @media (max-width: 400px) {
            .room-btn {
                min-width: 48px;
                padding: 5px 7px;
            }
            .room-btn-icon {
                font-size: 1.1rem;
            }
            .room-btn-label {
                font-size: 0.5rem;
            }
        }

        /* Stars overlay for night */
        .stars-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 40px;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Moon for nighttime */
        .moon {
            position: absolute;
            top: 15px;
            right: 20px;
            width: 35px;
            height: 35px;
            background: #FFFACD;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 250, 205, 0.6);
            z-index: 0;
        }

        /* Sun for daytime */
        .sun {
            position: absolute;
            top: 15px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: #FFD700;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            z-index: 0;
        }

        /* ==================== WEATHER SYSTEM ==================== */

        /* Weather overlay container */
        .weather-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 40px;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        /* Rain drops */
        .rain-drop {
            position: absolute;
            width: 2px;
            background: linear-gradient(transparent, rgba(174, 194, 224, 0.6));
            border-radius: 0 0 2px 2px;
            animation: rainFall linear infinite;
        }

        @keyframes rainFall {
            0% { transform: translateY(-20px); opacity: 0; }
            10% { opacity: 1; }
            100% { transform: translateY(280px); opacity: 0.3; }
        }

        /* Snowflakes */
        .snowflake {
            position: absolute;
            color: white;
            font-size: 0.8rem;
            opacity: 0.8;
            animation: snowFall linear infinite;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        }

        @keyframes snowFall {
            0% { transform: translateY(-10px) rotate(0deg); opacity: 0; }
            10% { opacity: 0.8; }
            100% { transform: translateY(280px) rotate(360deg); opacity: 0.2; }
        }

        /* Weather badge */
        .weather-badge {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 700;
            z-index: 3;
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }

        .weather-badge.sunny {
            background: rgba(255, 235, 59, 0.85);
            color: #F57F17;
        }

        .weather-badge.rainy {
            background: rgba(100, 181, 246, 0.85);
            color: #1565C0;
        }

        .weather-badge.snowy {
            background: rgba(255, 255, 255, 0.9);
            color: #546E7A;
        }

        /* Rainy background tint for outdoor rooms */
        .pet-area.weather-rainy {
            filter: brightness(0.9) saturate(0.85);
        }

        /* Snowy background tint for outdoor rooms */
        .pet-area.weather-snowy {
            filter: brightness(1.05) saturate(0.7);
        }

        /* Weather mood indicator on the mood message */
        .weather-mood-note {
            font-size: 0.75rem;
            opacity: 0.8;
            display: block;
            margin-top: 2px;
        }

        /* Time indicator */
        .time-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.2rem;
            z-index: 2;
        }

        /* Responsive Design */
        @media (max-width: 500px) {
            .game-container {
                padding: 15px;
                border-radius: 15px;
            }

            .game-title {
                font-size: 1.6rem;
            }

            .pet-area {
                padding: 15px;
                min-height: 180px;
            }

            .pet-svg {
                width: 120px;
                height: 120px;
            }

            .need-bubble {
                width: 50px;
                height: 50px;
            }

            .need-bubble-icon {
                font-size: 1.3rem;
            }

            .need-bubble-value {
                font-size: 0.6rem;
            }

            .action-btn {
                min-width: 60px;
                min-height: 60px;
                width: 60px;
                height: 60px;
                border-radius: 15px;
            }

            .btn-icon {
                font-size: 1.4rem;
            }
        }

        @media (max-width: 350px) {
            .action-group-buttons {
                flex-wrap: nowrap;
                overflow-x: auto;
                overflow-y: hidden;
                justify-content: flex-start;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                scrollbar-color: rgba(0,0,0,0.15) transparent;
            }

            .needs-row {
                gap: 8px;
            }

            .need-bubble {
                width: 44px;
                height: 44px;
            }

            .need-bubble-icon {
                font-size: 1.1rem;
            }

            .action-btn {
                min-width: 54px;
                min-height: 54px;
                width: 54px;
                height: 54px;
                font-size: 0.6rem;
            }

            .btn-icon {
                font-size: 1.2rem;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --color-text: #000000;
                --shadow: 0 4px 15px rgba(0,0,0,0.3);
            }

            .action-btn {
                border: 3px solid #000000;
            }

            .need-bubble {
                border: 2px solid #000000;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Mini Games Button */
        .action-btn.mini-games {
            background: linear-gradient(135deg, #7C4DFF, #536DFE);
        }

        /* Mini Games Menu Modal */
        .minigame-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .minigame-menu {
            background: white;
            border-radius: 25px;
            padding: 25px;
            max-width: 380px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        .minigame-menu-title {
            font-size: 1.5rem;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        .minigame-menu-subtitle {
            font-size: 0.85rem;
            color: #999;
            margin-bottom: 18px;
        }

        .minigame-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 18px;
        }

        .minigame-card {
            width: 100px;
            padding: 14px 8px;
            border: 2.5px solid #e0e0e0;
            border-radius: 18px;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .minigame-card:hover,
        .minigame-card:focus {
            border-color: #7C4DFF;
            background: #F3E5F5;
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(124,77,255,0.2);
        }

        .minigame-card-icon {
            font-size: 2rem;
        }

        .minigame-card-name {
            font-size: 0.8rem;
            font-weight: bold;
            color: var(--color-text);
        }

        .minigame-close-btn {
            padding: 10px 28px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            color: var(--color-text);
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .minigame-close-btn:hover,
        .minigame-close-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        /* Fetch Mini-Game */
        .fetch-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .fetch-game {
            background: white;
            border-radius: 25px;
            padding: 20px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        .fetch-game-title {
            font-size: 1.3rem;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        .fetch-game-score {
            font-size: 0.85rem;
            color: #7C4DFF;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .fetch-field {
            position: relative;
            width: 100%;
            height: 220px;
            border-radius: 18px;
            overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 55%, #7CB342 55%, #558B2F 100%);
            margin-bottom: 12px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .fetch-field-clouds {
            position: absolute;
            top: 8px;
            left: 0;
            right: 0;
            font-size: 1.2rem;
            opacity: 0.5;
            pointer-events: none;
            letter-spacing: 30px;
            text-align: center;
        }

        .fetch-field-flowers {
            position: absolute;
            bottom: 28px;
            left: 0;
            right: 0;
            font-size: 0.6rem;
            letter-spacing: 20px;
            text-align: center;
            pointer-events: none;
            opacity: 0.7;
            z-index: 1;
        }

        .fetch-ball {
            position: absolute;
            font-size: 1.8rem;
            z-index: 5;
            transition: none;
            pointer-events: none;
        }

        .fetch-ball.thrown {
            transition: left 0.6s ease-out, top 0.6s ease-out;
        }

        .fetch-ball.arc {
            transition: left 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), top 0.8s cubic-bezier(0.22, 0.61, 0.36, 1);
        }

        .fetch-pet {
            position: absolute;
            bottom: 10px;
            z-index: 3;
            transition: left 0.6s ease-in-out;
        }

        .fetch-pet svg {
            width: 70px;
            height: 70px;
        }

        .fetch-pet.running {
            transition: left 0.8s ease-in-out;
        }

        .fetch-pet.returning {
            transition: left 1.0s ease-in-out;
        }

        .fetch-instruction {
            font-size: 1rem;
            color: var(--color-text);
            margin-bottom: 10px;
            min-height: 1.4em;
        }

        .fetch-instruction.highlight {
            color: #7C4DFF;
            font-weight: bold;
            animation: feedbackPop 0.4s ease;
        }

        .fetch-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .fetch-throw-btn {
            padding: 12px 28px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #7C4DFF, #536DFE);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(124,77,255,0.3);
        }

        .fetch-throw-btn:hover:not(:disabled),
        .fetch-throw-btn:focus:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(124,77,255,0.4);
        }

        .fetch-throw-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .fetch-done-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            color: var(--color-text);
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .fetch-done-btn:hover,
        .fetch-done-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .fetch-reward {
            position: absolute;
            font-size: 1.2rem;
            font-weight: bold;
            color: #7C4DFF;
            animation: fetchRewardFloat 1s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes fetchRewardFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.3); }
        }

        .fetch-ball-shadow {
            position: absolute;
            width: 18px;
            height: 6px;
            background: rgba(0,0,0,0.15);
            border-radius: 50%;
            z-index: 2;
            pointer-events: none;
            transition: left 0.6s ease-out, opacity 0.3s;
        }

        /* Hide and Seek Mini-Game */
        .hideseek-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .hideseek-game {
            background: white;
            border-radius: 25px;
            padding: 20px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        .hideseek-game-title {
            font-size: 1.3rem;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        .hideseek-game-score {
            font-size: 0.85rem;
            color: #FF6D00;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .hideseek-game-timer {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 8px;
        }

        .hideseek-field {
            position: relative;
            width: 100%;
            height: 280px;
            border-radius: 18px;
            overflow: hidden;
            background: linear-gradient(180deg, #E8F5E9 0%, #C8E6C9 30%, #A5D6A7 60%, #81C784 100%);
            margin-bottom: 12px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .hideseek-hiding-spot {
            position: absolute;
            font-size: 2.2rem;
            cursor: pointer;
            transition: transform 0.15s ease;
            z-index: 3;
            filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.15));
        }

        .hideseek-hiding-spot:hover {
            transform: scale(1.15);
        }

        .hideseek-hiding-spot:active {
            transform: scale(0.95);
        }

        .hideseek-hiding-spot.searched {
            opacity: 0.4;
            cursor: default;
            pointer-events: none;
        }

        .hideseek-hiding-spot.found {
            animation: hideseekFound 0.6s ease forwards;
        }

        @keyframes hideseekFound {
            0% { transform: scale(1); }
            30% { transform: scale(1.3) rotate(-5deg); }
            60% { transform: scale(1.1) rotate(3deg); }
            100% { transform: scale(1); }
        }

        .hideseek-treat {
            position: absolute;
            font-size: 1.5rem;
            pointer-events: none;
            z-index: 5;
            animation: hideseekTreatPop 0.5s ease forwards;
        }

        @keyframes hideseekTreatPop {
            0% { opacity: 0; transform: scale(0) translateY(0); }
            50% { opacity: 1; transform: scale(1.3) translateY(-10px); }
            100% { opacity: 1; transform: scale(1) translateY(-5px); }
        }

        .hideseek-treat.collected {
            animation: hideseekTreatCollect 0.6s ease forwards;
        }

        @keyframes hideseekTreatCollect {
            0% { opacity: 1; transform: scale(1) translateY(-5px); }
            100% { opacity: 0; transform: scale(0.3) translateY(-50px); }
        }

        .hideseek-miss {
            position: absolute;
            font-size: 1.2rem;
            pointer-events: none;
            z-index: 5;
            animation: hideseekMiss 0.7s ease forwards;
        }

        @keyframes hideseekMiss {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .hideseek-pet {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            pointer-events: none;
            transition: left 0.5s ease, bottom 0.5s ease;
        }

        .hideseek-pet svg {
            width: 55px;
            height: 55px;
        }

        .hideseek-pet.celebrating {
            animation: hideseekCelebrate 0.5s ease;
        }

        @keyframes hideseekCelebrate {
            0% { transform: translateX(-50%) translateY(0); }
            25% { transform: translateX(-50%) translateY(-8px); }
            50% { transform: translateX(-50%) translateY(0); }
            75% { transform: translateX(-50%) translateY(-5px); }
            100% { transform: translateX(-50%) translateY(0); }
        }

        .hideseek-instruction {
            font-size: 1rem;
            color: var(--color-text);
            margin-bottom: 10px;
            min-height: 1.4em;
        }

        .hideseek-instruction.highlight {
            color: #FF6D00;
            font-weight: bold;
            animation: feedbackPop 0.4s ease;
        }

        .hideseek-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .hideseek-done-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            color: var(--color-text);
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .hideseek-done-btn:hover,
        .hideseek-done-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .hideseek-reward {
            position: absolute;
            font-size: 1.2rem;
            font-weight: bold;
            color: #FF6D00;
            animation: fetchRewardFloat 1s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }

        .hideseek-progress {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-bottom: 8px;
        }

        .hideseek-progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #E0E0E0;
            transition: background 0.3s ease, transform 0.3s ease;
        }

        .hideseek-progress-dot.found {
            background: #FF6D00;
            transform: scale(1.2);
        }

        /* Bubble Pop Mini-Game */
        .bubblepop-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .bubblepop-game {
            background: white;
            border-radius: 25px;
            padding: 20px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        .bubblepop-game-title {
            font-size: 1.3rem;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        .bubblepop-game-score {
            font-size: 0.85rem;
            color: #29B6F6;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .bubblepop-game-timer {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 8px;
        }

        .bubblepop-field {
            position: relative;
            width: 100%;
            height: 300px;
            border-radius: 18px;
            overflow: hidden;
            background: linear-gradient(180deg, #E1F5FE 0%, #B3E5FC 30%, #81D4FA 60%, #4FC3F7 100%);
            margin-bottom: 12px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .bubblepop-suds {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.6) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .bubblepop-bubble {
            position: absolute;
            border-radius: 50%;
            cursor: pointer;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s ease;
            background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.3) 30%, rgba(173,216,255,0.3) 60%, rgba(173,216,255,0.1) 100%);
            border: 2px solid rgba(255,255,255,0.6);
            box-shadow: inset 0 -3px 6px rgba(173,216,255,0.3), 0 2px 8px rgba(0,0,0,0.08);
        }

        .bubblepop-bubble::after {
            content: '';
            position: absolute;
            top: 18%;
            left: 22%;
            width: 30%;
            height: 20%;
            background: rgba(255,255,255,0.7);
            border-radius: 50%;
            transform: rotate(-30deg);
        }

        .bubblepop-bubble:hover {
            transform: scale(1.1);
        }

        .bubblepop-bubble:active {
            transform: scale(0.9);
        }

        .bubblepop-bubble.popping {
            animation: bubblePop 0.35s ease forwards;
            pointer-events: none;
        }

        @keyframes bubblePop {
            0% { transform: scale(1); opacity: 1; }
            40% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }

        @keyframes bubbleFloat {
            0% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-5px) translateX(3px); }
            50% { transform: translateY(0) translateX(-3px); }
            75% { transform: translateY(5px) translateX(2px); }
            100% { transform: translateY(0) translateX(0); }
        }

        .bubblepop-splash {
            position: absolute;
            font-size: 1.2rem;
            pointer-events: none;
            z-index: 5;
            animation: bubbleSplash 0.6s ease forwards;
        }

        @keyframes bubbleSplash {
            0% { opacity: 1; transform: scale(0.5) translateY(0); }
            50% { opacity: 1; transform: scale(1.2) translateY(-10px); }
            100% { opacity: 0; transform: scale(0.8) translateY(-25px); }
        }

        .bubblepop-pet {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            pointer-events: none;
        }

        .bubblepop-pet svg {
            width: 60px;
            height: 60px;
        }

        .bubblepop-pet.splashing {
            animation: bubbleSplash-pet 0.4s ease;
        }

        @keyframes bubbleSplash-pet {
            0% { transform: translateX(-50%) translateY(0); }
            30% { transform: translateX(-50%) translateY(-6px); }
            60% { transform: translateX(-50%) translateY(0); }
            80% { transform: translateX(-50%) translateY(-3px); }
            100% { transform: translateX(-50%) translateY(0); }
        }

        .bubblepop-instruction {
            font-size: 1rem;
            color: var(--color-text);
            margin-bottom: 10px;
            min-height: 1.4em;
        }

        .bubblepop-instruction.highlight {
            color: #29B6F6;
            font-weight: bold;
            animation: feedbackPop 0.4s ease;
        }

        .bubblepop-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .bubblepop-done-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            color: var(--color-text);
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .bubblepop-done-btn:hover,
        .bubblepop-done-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .bubblepop-reward {
            position: absolute;
            font-size: 1.2rem;
            font-weight: bold;
            color: #29B6F6;
            animation: fetchRewardFloat 1s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }

        /* Matching Mini-Game */
        .matching-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .matching-game {
            background: white;
            border-radius: 25px;
            padding: 20px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        .matching-game-title {
            font-size: 1.3rem;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        .matching-game-score {
            font-size: 0.85rem;
            color: #AB47BC;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .matching-game-moves {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 8px;
        }

        .matching-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 12px;
            background: linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 50%, #CE93D8 100%);
            border-radius: 18px;
            margin-bottom: 12px;
        }

        .matching-card {
            aspect-ratio: 1;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            perspective: 400px;
            background: transparent;
            padding: 0;
            font-family: inherit;
        }

        .matching-card:focus {
            outline: 3px solid #AB47BC;
            outline-offset: 2px;
        }

        .matching-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.4s ease;
            transform-style: preserve-3d;
            border-radius: 12px;
        }

        .matching-card.flipped .matching-card-inner,
        .matching-card.matched .matching-card-inner {
            transform: rotateY(180deg);
        }

        .matching-card-front,
        .matching-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
        }

        .matching-card-front {
            background: linear-gradient(135deg, #7E57C2, #AB47BC);
            color: white;
            box-shadow: 0 3px 8px rgba(126,87,194,0.3);
        }

        .matching-card-back {
            background: white;
            transform: rotateY(180deg);
            box-shadow: 0 3px 8px rgba(0,0,0,0.1);
            border: 2px solid #E1BEE7;
        }

        .matching-card.matched .matching-card-back {
            background: #F3E5F5;
            border-color: #AB47BC;
        }

        .matching-card.matched {
            pointer-events: none;
        }

        .matching-card.celebrating {
            animation: matchCelebrate 0.5s ease;
        }

        @keyframes matchCelebrate {
            0% { transform: scale(1); }
            30% { transform: scale(1.1) rotate(-3deg); }
            60% { transform: scale(1.05) rotate(3deg); }
            100% { transform: scale(1) rotate(0); }
        }

        .matching-instruction {
            font-size: 1rem;
            color: var(--color-text);
            margin-bottom: 10px;
            min-height: 1.4em;
        }

        .matching-instruction.highlight {
            color: #AB47BC;
            font-weight: bold;
            animation: feedbackPop 0.4s ease;
        }

        .matching-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .matching-done-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            color: var(--color-text);
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .matching-done-btn:hover,
        .matching-done-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        /* Simon Says Mini-Game */
        .simonsays-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .simonsays-game {
            background: white;
            border-radius: 25px;
            padding: 20px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        .simonsays-game-title {
            font-size: 1.3rem;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        .simonsays-game-score {
            font-size: 0.85rem;
            color: #FF7043;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .simonsays-game-round {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 8px;
        }

        .simonsays-board {
            position: relative;
            width: 260px;
            height: 260px;
            margin: 0 auto 12px;
            border-radius: 50%;
            background: #333;
            padding: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            user-select: none;
            -webkit-user-select: none;
        }

        .simonsays-pad-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
        }

        .simonsays-pad {
            position: absolute;
            width: 50%;
            height: 50%;
            border: none;
            cursor: pointer;
            transition: filter 0.1s ease, transform 0.1s ease;
            padding: 0;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .simonsays-pad:focus {
            outline: 3px solid white;
            outline-offset: -3px;
            z-index: 2;
        }

        .simonsays-pad[data-color="green"] {
            top: 0;
            left: 0;
            background: #4CAF50;
            border-radius: 100% 0 0 0;
        }

        .simonsays-pad[data-color="red"] {
            top: 0;
            right: 0;
            background: #F44336;
            border-radius: 0 100% 0 0;
        }

        .simonsays-pad[data-color="yellow"] {
            bottom: 0;
            left: 0;
            background: #FFEB3B;
            border-radius: 0 0 0 100%;
        }

        .simonsays-pad[data-color="blue"] {
            bottom: 0;
            right: 0;
            background: #2196F3;
            border-radius: 0 0 100% 0;
        }

        .simonsays-pad.lit {
            filter: brightness(1.6);
            transform: scale(1.03);
            z-index: 1;
        }

        .simonsays-pad.disabled {
            cursor: not-allowed;
            filter: brightness(0.6);
        }

        .simonsays-pad:not(.disabled):hover {
            filter: brightness(1.2);
        }

        .simonsays-pad:not(.disabled):active {
            filter: brightness(1.5);
            transform: scale(0.97);
        }

        .simonsays-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #333;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.4);
        }

        .simonsays-center-pet svg {
            width: 45px;
            height: 45px;
        }

        .simonsays-center-pet.bouncing {
            animation: simonBounce 0.4s ease;
        }

        @keyframes simonBounce {
            0% { transform: scale(1); }
            30% { transform: scale(1.15); }
            60% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        .simonsays-instruction {
            font-size: 1rem;
            color: var(--color-text);
            margin-bottom: 10px;
            min-height: 1.4em;
        }

        .simonsays-instruction.highlight {
            color: #FF7043;
            font-weight: bold;
            animation: feedbackPop 0.4s ease;
        }

        .simonsays-instruction.watching {
            color: #9575CD;
            font-weight: bold;
        }

        .simonsays-instruction.your-turn {
            color: #4CAF50;
            font-weight: bold;
        }

        .simonsays-instruction.wrong {
            color: #F44336;
            font-weight: bold;
        }

        .simonsays-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .simonsays-done-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            color: var(--color-text);
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .simonsays-done-btn:hover,
        .simonsays-done-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .simonsays-streak {
            position: absolute;
            font-size: 1.1rem;
            font-weight: bold;
            color: #FF7043;
            animation: fetchRewardFloat 1s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }

        /* Coloring mini-game */
        .coloring-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .coloring-game {
            background: white;
            border-radius: 25px;
            padding: 15px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
            max-height: 95vh;
            overflow-y: auto;
        }

        .coloring-game-title {
            font-size: 1.3rem;
            color: var(--color-text);
            margin-bottom: 4px;
        }

        .coloring-game-hint {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        .coloring-canvas-wrap {
            background: white;
            border: 3px solid #ddd;
            border-radius: 15px;
            padding: 5px;
            margin-bottom: 10px;
            display: inline-block;
            width: 100%;
            max-width: 320px;
        }

        .coloring-scene {
            width: 100%;
            height: auto;
            display: block;
        }

        .coloring-region {
            cursor: pointer;
            transition: opacity 0.15s ease;
        }

        .coloring-region:hover {
            opacity: 0.85;
        }

        .coloring-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            margin-bottom: 12px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 12px;
        }

        .coloring-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 3px solid #ddd;
            cursor: pointer;
            transition: all 0.15s ease;
            padding: 0;
            font-size: 0;
        }

        .coloring-swatch:hover,
        .coloring-swatch:focus {
            transform: scale(1.15);
            border-color: #666;
        }

        .coloring-swatch.selected {
            border-color: #333;
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .coloring-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .coloring-clear-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
            color: var(--color-text);
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .coloring-clear-btn:hover,
        .coloring-clear-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .coloring-done-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, #81C784, #4CAF50);
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .coloring-done-btn:hover,
        .coloring-done-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        /* Child-friendly modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 25px;
            padding: 30px;
            max-width: 350px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        @keyframes modalPop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: var(--color-text);
            margin-bottom: 10px;
        }

        .modal-message {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 25px;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            min-width: 100px;
            padding: 15px 25px;
            border: none;
            border-radius: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .modal-btn.confirm {
            background: linear-gradient(135deg, #FF6B6B, #EE5A5A);
            color: white;
        }

        .modal-btn.cancel {
            background: linear-gradient(135deg, #4ECDC4, #45B7AA);
            color: white;
        }

        .modal-btn:hover,
        .modal-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* ===== Action Button Groups ===== */
        .action-group {
            margin-bottom: 6px;
        }

        .action-group:last-child {
            margin-bottom: 0;
        }

        .action-group-label {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #aaa;
            margin-bottom: 6px;
            padding-left: 4px;
        }

        .action-group-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* ===== Enhanced Critical Need Warnings ===== */
        .need-bubble.critical {
            animation: criticalPulse 1s ease-in-out infinite;
            box-shadow: 0 0 0 0 rgba(239, 83, 80, 0.4);
        }

        @keyframes criticalPulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 83, 80, 0.5); }
            50% { box-shadow: 0 0 12px 4px rgba(239, 83, 80, 0.35); }
            100% { box-shadow: 0 0 0 0 rgba(239, 83, 80, 0.5); }
        }

        .need-bubble.critical .need-bubble-icon {
            animation: criticalBounce 0.6s ease-in-out infinite;
        }

        @keyframes criticalBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.25); }
        }

        .need-bubble.warning {
            box-shadow: 0 0 8px 2px rgba(255, 167, 38, 0.25);
        }

        /* ===== Toast Notifications ===== */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: none;
        }

        .toast {
            background: white;
            padding: 10px 20px;
            border-radius: 14px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            font-size: 1rem;
            font-weight: bold;
            font-family: inherit;
            animation: toastIn 0.4s ease forwards, toastOut 0.4s ease 2s forwards;
            white-space: nowrap;
            border-left: 4px solid var(--toast-color, #66BB6A);
        }

        @keyframes toastIn {
            0% { opacity: 0; transform: translateY(-20px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes toastOut {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-10px) scale(0.95); }
        }

        /* ===== Pet Naming Modal ===== */
        .naming-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        .naming-modal {
            background: white;
            border-radius: 25px;
            padding: 30px;
            max-width: 350px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalPop 0.3s ease;
        }

        .naming-modal-icon {
            font-size: 3.5rem;
            margin-bottom: 10px;
        }

        .naming-modal-title {
            font-size: 1.4rem;
            color: var(--color-text);
            margin-bottom: 6px;
        }

        .naming-modal-subtitle {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 18px;
        }

        .naming-input {
            width: 100%;
            padding: 12px 16px;
            font-size: 1.1rem;
            font-family: inherit;
            border: 2.5px solid #e0e0e0;
            border-radius: 14px;
            text-align: center;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            margin-bottom: 16px;
        }

        .naming-input:focus {
            border-color: var(--color-secondary);
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.2);
        }

        .naming-input::placeholder {
            color: #ccc;
        }

        .naming-submit-btn {
            padding: 12px 32px;
            border: none;
            border-radius: 14px;
            background: linear-gradient(135deg, var(--color-secondary), #45B7AA);
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
            box-shadow: 0 3px 10px rgba(78, 205, 196, 0.3);
        }

        .naming-submit-btn:hover,
        .naming-submit-btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .naming-skip-btn {
            display: block;
            margin: 10px auto 0;
            padding: 6px 16px;
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 0.8rem;
            cursor: pointer;
            font-family: inherit;
            transition: color 0.2s ease;
        }

        .naming-skip-btn:hover {
            color: #666;
        }

    </style>
</head>
<body>
    <div class="toast-container" id="toast-container"></div>
    <a href="#main-game" class="skip-link">Skip to game</a>

    <main id="main-game" class="game-container" role="main" aria-label="Pet Care Buddy Game">
        <header class="game-header">
            <h1 class="game-title">Pet Care Buddy</h1>
        </header>

        <div id="game-content">
            <!-- Game content will be dynamically inserted here -->
        </div>

        <!-- Live region for screen reader announcements -->
        <div id="live-announcer" class="live-region" aria-live="polite" aria-atomic="true"></div>
        <div id="live-announcer-assertive" class="live-region" aria-live="assertive" aria-atomic="true"></div>
    </main>

    <script>
        // Pet Care Buddy Game - Main JavaScript

        // ==================== GAME DATA ====================

        const PET_TYPES = {
            dog: {
                name: 'Puppy',
                emoji: 'üêï',
                colors: ['#D4A574', '#8B7355', '#F5DEB3', '#A0522D', '#FFE4C4'],
                sounds: ['Woof!', 'Bark!', 'Arf!'],
                happySounds: ['Happy bark!', 'Tail wagging!', 'Playful woof!'],
                sadSounds: ['Whimper...', 'Sad whine...']
            },
            cat: {
                name: 'Kitty',
                emoji: 'üê±',
                colors: ['#FFA500', '#808080', '#FFFFFF', '#000000', '#DEB887'],
                sounds: ['Meow!', 'Purr!', 'Mew!'],
                happySounds: ['Loud purring!', 'Happy meow!', 'Content purr!'],
                sadSounds: ['Sad meow...', 'Quiet mew...']
            },
            bunny: {
                name: 'Bunny',
                emoji: 'üê∞',
                colors: ['#FFFFFF', '#D4A574', '#808080', '#F5DEB3', '#FFB6C1'],
                sounds: ['Hop hop!', 'Sniff sniff!', 'Thump!'],
                happySounds: ['Binky jump!', 'Happy hop!', 'Excited thump!'],
                sadSounds: ['Quiet sniff...', 'Slow hop...']
            },
            bird: {
                name: 'Birdie',
                emoji: 'üê¶',
                colors: ['#FFD700', '#87CEEB', '#98FB98', '#FF6347', '#DDA0DD'],
                sounds: ['Tweet!', 'Chirp!', 'Whistle!'],
                happySounds: ['Happy song!', 'Joyful chirp!', 'Cheerful tweet!'],
                sadSounds: ['Quiet chirp...', 'Soft tweet...']
            },
            hamster: {
                name: 'Hammy',
                emoji: 'üêπ',
                colors: ['#D4A574', '#F5DEB3', '#FFFFFF', '#DEB887', '#FFE4C4'],
                sounds: ['Squeak!', 'Nibble nibble!', 'Scurry!'],
                happySounds: ['Happy squeak!', 'Wheel spinning!', 'Excited nibble!'],
                sadSounds: ['Soft squeak...', 'Quiet nibble...']
            },
            turtle: {
                name: 'Shelly',
                emoji: 'üê¢',
                colors: ['#228B22', '#556B2F', '#6B8E23', '#8FBC8F', '#2E8B57'],
                sounds: ['*slow blink*', '*head bob*', '*shell tap*'],
                happySounds: ['Happy waddle!', 'Excited stretch!', 'Shell shimmy!'],
                sadSounds: ['Hiding in shell...', 'Slow retreat...']
            }
        };

        const TREAT_TYPES = [
            { name: 'Cookie', emoji: 'üç™' },
            { name: 'Cupcake', emoji: 'üßÅ' },
            { name: 'Ice Cream', emoji: 'üç¶' },
            { name: 'Candy', emoji: 'üç¨' },
            { name: 'Donut', emoji: 'üç©' },
            { name: 'Honey', emoji: 'üçØ' }
        ];

        const FEEDBACK_MESSAGES = {
            feed: ['Yummy!', 'Delicious!', 'So tasty!', 'Nom nom!', 'Thank you!'],
            wash: ['So clean!', 'Sparkly!', 'Fresh!', 'Squeaky clean!', 'Shiny!'],
            play: ['So fun!', 'Wheee!', 'Again!', 'Yay!', 'Love it!'],
            sleep: ['So cozy!', 'Sweet dreams!', 'Zzz...', 'Night night!', 'Sleepy time!'],
            medicine: ['All better!', 'Feeling great!', 'So much better!', 'Healthy!', 'Happy again!'],
            groom: ['So fluffy!', 'Looking good!', 'Nice and tidy!', 'Beautiful!', 'Well groomed!'],
            exercise: ['Great run!', 'I fetched it!', 'So much fun!', 'Let\'s go again!', 'What a workout!'],
            treat: ['Yummy treat!', 'So special!', 'Best snack ever!', 'More please!', 'What a delight!'],
            cuddle: ['So cozy!', 'Loves cuddles!', 'Purr purr!', 'Snuggle time!', 'More pets please!']
        };

        const MOOD_MESSAGES = {
            happy: ['is super happy!', 'is feeling great!', 'is full of joy!', 'loves you!'],
            neutral: ['is doing okay.', 'is content.', 'is relaxed.'],
            sad: ['needs some love.', 'misses you.', 'wants attention.'],
            sleepy: ['is getting sleepy...', 'is yawning!', 'can barely keep eyes open...', 'is ready for bed!'],
            energetic: ['is full of energy!', 'is bright-eyed and bushy-tailed!', 'is raring to go!', 'had a great sleep!']
        };

        // ==================== WEATHER SYSTEM ====================

        const WEATHER_TYPES = {
            sunny: {
                name: 'Sunny',
                icon: '‚òÄÔ∏è',
                moodBonus: 5,
                happinessDecayModifier: 0,
                energyDecayModifier: 0,
                cleanlinessDecayModifier: 0,
                messages: [
                    'loves the sunny weather!',
                    'is soaking up the sunshine!',
                    'is basking in the warm sun!'
                ]
            },
            rainy: {
                name: 'Rainy',
                icon: 'üåßÔ∏è',
                moodBonus: -5,
                happinessDecayModifier: 1,
                energyDecayModifier: 0,
                cleanlinessDecayModifier: 1,
                messages: [
                    'doesn\'t love the rain...',
                    'is a bit gloomy from the rain.',
                    'wants to stay dry inside.'
                ]
            },
            snowy: {
                name: 'Snowy',
                icon: 'üå®Ô∏è',
                moodBonus: -3,
                happinessDecayModifier: 0,
                energyDecayModifier: 1,
                cleanlinessDecayModifier: 0,
                messages: [
                    'is watching the snowflakes!',
                    'shivers a little in the snow.',
                    'thinks the snow is pretty!'
                ]
            }
        };

        const WEATHER_CHANGE_INTERVAL = 300000; // Check for weather change every 5 minutes

        // ==================== ROOMS ====================

        const ROOMS = {
            bedroom: {
                name: 'Bedroom',
                icon: 'üõèÔ∏è',
                isOutdoor: false,
                ground: { color1: '#8D6E63', color2: '#6D4C41' },
                decorEmoji: 'üõèÔ∏è üß∏ üåô',
                nightDecorEmoji: 'üõèÔ∏è üß∏ üí§',
                bgDay: 'linear-gradient(180deg, #E8D5B7 0%, #F5E6CC 50%, #DCC8A0 100%)',
                bgNight: 'linear-gradient(180deg, #3E2723 0%, #4E342E 50%, #5D4037 100%)',
                bgSunset: 'linear-gradient(180deg, #D7CCC8 0%, #EFEBE9 50%, #DCC8A0 100%)',
                bgSunrise: 'linear-gradient(180deg, #FFF3E0 0%, #FFE0B2 50%, #DCC8A0 100%)'
            },
            kitchen: {
                name: 'Kitchen',
                icon: 'üç≥',
                isOutdoor: false,
                ground: { color1: '#BDBDBD', color2: '#9E9E9E' },
                decorEmoji: 'üç≥ üßÅ üçé',
                nightDecorEmoji: 'üç≥ üßÅ üç™',
                bgDay: 'linear-gradient(180deg, #FFF9C4 0%, #FFFDE7 50%, #FFF59D 100%)',
                bgNight: 'linear-gradient(180deg, #33302A 0%, #3E3A32 50%, #4A4538 100%)',
                bgSunset: 'linear-gradient(180deg, #FFE0B2 0%, #FFF8E1 50%, #FFF59D 100%)',
                bgSunrise: 'linear-gradient(180deg, #FFF8E1 0%, #FFFDE7 50%, #FFF59D 100%)'
            },
            bathroom: {
                name: 'Bathroom',
                icon: 'üõÅ',
                isOutdoor: false,
                ground: { color1: '#80DEEA', color2: '#4DD0E1' },
                decorEmoji: 'üõÅ üß¥ ü´ß',
                nightDecorEmoji: 'üõÅ üß¥ üåä',
                bgDay: 'linear-gradient(180deg, #E0F7FA 0%, #B2EBF2 50%, #80DEEA 100%)',
                bgNight: 'linear-gradient(180deg, #1A3A3A 0%, #1E4D4D 50%, #1B3F3F 100%)',
                bgSunset: 'linear-gradient(180deg, #B2EBF2 0%, #E0F7FA 50%, #80DEEA 100%)',
                bgSunrise: 'linear-gradient(180deg, #E0F7FA 0%, #B2EBF2 50%, #80DEEA 100%)'
            },
            backyard: {
                name: 'Backyard',
                icon: 'üè°',
                isOutdoor: true,
                ground: { color1: '#7CB342', color2: '#558B2F' },
                decorEmoji: 'üåª ü¶ã üåø',
                nightDecorEmoji: 'üåø ü¶ó üåø',
                bgDay: 'linear-gradient(180deg, #87CEEB 0%, #98FB98 100%)',
                bgNight: 'linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',
                bgSunset: 'linear-gradient(180deg, #FF7E5F 0%, #FEB47B 50%, #98FB98 100%)',
                bgSunrise: 'linear-gradient(180deg, #ffecd2 0%, #fcb69f 50%, #98FB98 100%)'
            },
            park: {
                name: 'Park',
                icon: 'üå≥',
                isOutdoor: true,
                ground: { color1: '#66BB6A', color2: '#43A047' },
                decorEmoji: 'üå≥ üå∫ ü¶Ü',
                nightDecorEmoji: 'üå≥ üçÉ ü¶â',
                bgDay: 'linear-gradient(180deg, #64B5F6 0%, #81C784 100%)',
                bgNight: 'linear-gradient(180deg, #0D1B2A 0%, #1B2838 50%, #1A472A 100%)',
                bgSunset: 'linear-gradient(180deg, #FF8A65 0%, #FFB74D 50%, #81C784 100%)',
                bgSunrise: 'linear-gradient(180deg, #FFCCBC 0%, #FFE0B2 50%, #81C784 100%)'
            }
        };

        const ROOM_IDS = Object.keys(ROOMS);

        // ==================== GAME STATE ====================

        let gameState = {
            phase: 'egg', // 'egg', 'hatching', 'pet'
            pet: null,
            eggTaps: 0,
            lastUpdate: Date.now(),
            timeOfDay: 'day', // 'day', 'sunset', 'night', 'sunrise'
            currentRoom: 'bedroom', // 'bedroom', 'kitchen', 'bathroom', 'backyard', 'park'
            weather: 'sunny', // 'sunny', 'rainy', 'snowy'
            lastWeatherChange: Date.now()
        };

        let weatherInterval = null;

        // ==================== UTILITY FUNCTIONS ====================

        function randomFromArray(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Dynamic color for need rings: green when high, yellow, orange, red when low
        function getNeedColor(value) {
            if (value > 65) return '#66BB6A';
            if (value > 45) return '#FDD835';
            if (value > 25) return '#FFA726';
            return '#EF5350';
        }

        function announce(message, assertive = false) {
            const announcer = document.getElementById(assertive ? 'live-announcer-assertive' : 'live-announcer');
            announcer.textContent = '';
            setTimeout(() => {
                announcer.textContent = message;
            }, 100);
        }

        // ==================== SAVE/LOAD ====================

        function saveGame() {
            try {
                gameState.lastUpdate = Date.now();
                localStorage.setItem('petCareBuddy', JSON.stringify(gameState));
            } catch (e) {
                console.log('Could not save game:', e);
                if (e.name === 'QuotaExceededError' || e.code === 22) {
                    showToast('Storage full! Progress may not be saved.', '#EF5350');
                }
            }
        }

        function loadGame() {
            try {
                const saved = localStorage.getItem('petCareBuddy');
                if (saved) {
                    const parsed = JSON.parse(saved);

                    // Validate saved data structure
                    if (!parsed || typeof parsed !== 'object') {
                        return null;
                    }

                    // Handle stuck 'hatching' phase - reset to egg
                    if (parsed.phase === 'hatching') {
                        parsed.phase = 'egg';
                        parsed.eggTaps = 0;
                    }

                    // Validate pet data if in pet phase
                    if (parsed.phase === 'pet') {
                        if (!parsed.pet ||
                            typeof parsed.pet.hunger !== 'number' ||
                            typeof parsed.pet.cleanliness !== 'number' ||
                            typeof parsed.pet.happiness !== 'number' ||
                            !parsed.pet.type ||
                            !PET_TYPES[parsed.pet.type]) {
                            // Corrupted pet data, start fresh
                            return null;
                        }
                        // Add energy stat if missing (for existing saves)
                        if (typeof parsed.pet.energy !== 'number') {
                            parsed.pet.energy = 70;
                        }
                    }

                    // Add currentRoom if missing (for existing saves)
                    if (!parsed.currentRoom || !ROOMS[parsed.currentRoom]) {
                        parsed.currentRoom = 'bedroom';
                    }

                    // Add weather if missing (for existing saves)
                    if (!parsed.weather || !WEATHER_TYPES[parsed.weather]) {
                        parsed.weather = 'sunny';
                    }
                    if (!parsed.lastWeatherChange) {
                        parsed.lastWeatherChange = Date.now();
                    }

                    // Update time of day
                    parsed.timeOfDay = getTimeOfDay();

                    // Apply time-based decay for needs
                    if (parsed.pet && parsed.lastUpdate) {
                        const timePassed = Date.now() - parsed.lastUpdate;
                        const minutesPassed = timePassed / 60000;
                        // Decrease needs by 1 point per 2 minutes (slower decay for young children)
                        const decay = Math.floor(minutesPassed / 2);
                        if (decay > 0) {
                            parsed.pet.hunger = clamp(parsed.pet.hunger - decay, 0, 100);
                            parsed.pet.cleanliness = clamp(parsed.pet.cleanliness - decay, 0, 100);
                            parsed.pet.happiness = clamp(parsed.pet.happiness - decay, 0, 100);
                            parsed.pet.energy = clamp(parsed.pet.energy - decay, 0, 100);
                        }
                    }
                    return parsed;
                }
            } catch (e) {
                console.log('Could not load game:', e);
                // Clear corrupted data
                try {
                    localStorage.removeItem('petCareBuddy');
                } catch (clearError) {
                    // Ignore clear errors
                }
            }
            return null;
        }

        // ==================== PET CREATION ====================

        function createPet() {
            const types = Object.keys(PET_TYPES);
            const type = randomFromArray(types);
            const petData = PET_TYPES[type];
            const color = randomFromArray(petData.colors);

            return {
                type: type,
                name: petData.name,
                color: color,
                hunger: 70,
                cleanliness: 70,
                happiness: 70,
                energy: 70
            };
        }

        function getMood(pet) {
            const average = (pet.hunger + pet.cleanliness + pet.happiness + pet.energy) / 4;
            // Weather affects mood thresholds when pet is outdoors
            const weather = gameState.weather || 'sunny';
            const weatherData = WEATHER_TYPES[weather];
            const room = ROOMS[gameState.currentRoom || 'bedroom'];
            const isOutdoor = room ? room.isOutdoor : false;
            const weatherBonus = isOutdoor ? weatherData.moodBonus : 0;
            const adjusted = average + weatherBonus;

            // Day/Night cycle mood overrides
            const timeOfDay = gameState.timeOfDay || 'day';
            const isNightTime = (timeOfDay === 'night' || timeOfDay === 'sunset');
            const isMorning = (timeOfDay === 'sunrise');

            // Sleepy at night when energy is low-ish
            if (isNightTime && pet.energy < 50) return 'sleepy';

            // Energetic in the morning when energy is decent
            if (isMorning && pet.energy >= 50) return 'energetic';

            if (adjusted >= 60) return 'happy';
            if (adjusted >= 30) return 'neutral';
            return 'sad';
        }

        // Get time of day based on real time
        function getTimeOfDay() {
            const hour = new Date().getHours();
            if (hour >= 6 && hour < 8) return 'sunrise';
            if (hour >= 8 && hour < 18) return 'day';
            if (hour >= 18 && hour < 20) return 'sunset';
            return 'night';
        }

        // Get time icon based on time of day
        function getTimeIcon(timeOfDay) {
            switch (timeOfDay) {
                case 'sunrise': return 'üåÖ';
                case 'day': return '‚òÄÔ∏è';
                case 'sunset': return 'üåá';
                case 'night': return 'üåô';
                default: return '‚òÄÔ∏è';
            }
        }

        // ==================== WEATHER FUNCTIONS ====================

        function getRandomWeather() {
            const rand = Math.random();
            if (rand < 0.5) return 'sunny';
            if (rand < 0.8) return 'rainy';
            return 'snowy';
        }

        function checkWeatherChange() {
            const now = Date.now();
            if (now - gameState.lastWeatherChange >= WEATHER_CHANGE_INTERVAL) {
                const newWeather = getRandomWeather();
                if (newWeather !== gameState.weather) {
                    gameState.weather = newWeather;
                    const weatherData = WEATHER_TYPES[newWeather];
                    showToast(`${weatherData.icon} Weather changed to ${weatherData.name}!`, newWeather === 'sunny' ? '#FFD700' : newWeather === 'rainy' ? '#64B5F6' : '#B0BEC5');
                    announce(`The weather is now ${weatherData.name.toLowerCase()}.`);
                    updateWeatherDisplay();
                    updatePetMood();
                }
                gameState.lastWeatherChange = now;
                saveGame();
            }
        }

        function generateWeatherHTML(weather) {
            if (weather === 'rainy') {
                let drops = '';
                for (let i = 0; i < 30; i++) {
                    const left = Math.random() * 100;
                    const delay = Math.random() * 2;
                    const duration = 0.6 + Math.random() * 0.4;
                    const height = 15 + Math.random() * 15;
                    drops += `<div class="rain-drop" style="left:${left}%;height:${height}px;animation-delay:${delay}s;animation-duration:${duration}s;"></div>`;
                }
                return `<div class="weather-overlay">${drops}</div>`;
            }
            if (weather === 'snowy') {
                let flakes = '';
                const snowChars = ['‚ùÑ', '‚ùÜ', '‚ú¶'];
                for (let i = 0; i < 20; i++) {
                    const left = Math.random() * 100;
                    const delay = Math.random() * 3;
                    const duration = 2 + Math.random() * 2;
                    const char = snowChars[Math.floor(Math.random() * snowChars.length)];
                    flakes += `<div class="snowflake" style="left:${left}%;animation-delay:${delay}s;animation-duration:${duration}s;">${char}</div>`;
                }
                return `<div class="weather-overlay">${flakes}</div>`;
            }
            return '';
        }

        function getTimeMoodMessage(pet) {
            const timeOfDay = gameState.timeOfDay || 'day';
            if (timeOfDay === 'night' && pet.energy < 50) {
                return randomFromArray(['is getting very sleepy...', 'could really use some sleep!', 'keeps nodding off...']);
            }
            if (timeOfDay === 'night' && pet.energy >= 50) {
                return 'is staying up late!';
            }
            if (timeOfDay === 'sunset' && pet.energy < 40) {
                return 'is winding down for the evening.';
            }
            if (timeOfDay === 'sunrise' && pet.energy >= 50) {
                return randomFromArray(['is bright-eyed this morning!', 'woke up ready for fun!', 'is greeting the sunrise!']);
            }
            return '';
        }

        function getWeatherMoodMessage(pet, weather) {
            if (weather === 'sunny') return '';
            const weatherData = WEATHER_TYPES[weather];
            const room = ROOMS[gameState.currentRoom || 'bedroom'];
            if (room.isOutdoor) {
                return randomFromArray(weatherData.messages);
            }
            if (weather === 'rainy') return 'can hear the rain outside.';
            if (weather === 'snowy') return 'is cozy inside while it snows.';
            return '';
        }

        function startWeatherTimer() {
            if (weatherInterval) clearInterval(weatherInterval);
            weatherInterval = setInterval(() => {
                if (gameState.phase === 'pet' && !document.hidden) {
                    checkWeatherChange();
                }
            }, 60000); // Check every minute
        }

        function stopWeatherTimer() {
            if (weatherInterval) {
                clearInterval(weatherInterval);
                weatherInterval = null;
            }
        }

        // Generate stars for nighttime
        function generateStarsHTML() {
            let stars = '';
            for (let i = 0; i < 15; i++) {
                const left = Math.random() * 90 + 5;
                const top = Math.random() * 60 + 5;
                const delay = Math.random() * 2;
                const size = Math.random() * 3 + 2;
                stars += `<div class="star" style="left: ${left}%; top: ${top}%; width: ${size}px; height: ${size}px; animation-delay: ${delay}s;"></div>`;
            }
            return stars;
        }

        // ==================== ROOM FUNCTIONS ====================

        function getRoomBackground(roomId, timeOfDay) {
            const room = ROOMS[roomId];
            if (!room) return ROOMS.bedroom.bgDay;
            switch (timeOfDay) {
                case 'night': return room.bgNight;
                case 'sunset': return room.bgSunset;
                case 'sunrise': return room.bgSunrise;
                default: return room.bgDay;
            }
        }

        function getRoomDecor(roomId, timeOfDay) {
            const room = ROOMS[roomId];
            if (!room) return 'üå∏ üåº üå∑';
            return timeOfDay === 'night' ? room.nightDecorEmoji : room.decorEmoji;
        }

        function generateRoomNavHTML(currentRoom) {
            let html = '<nav class="room-nav" role="navigation" aria-label="Room navigation">';
            for (const id of ROOM_IDS) {
                const room = ROOMS[id];
                const isActive = id === currentRoom;
                html += `<button class="room-btn${isActive ? ' active' : ''}" data-room="${id}"
                    aria-label="Go to ${room.name}" aria-pressed="${isActive}"
                    ${isActive ? 'aria-current="true"' : ''}>
                    <span class="room-btn-icon" aria-hidden="true">${room.icon}</span>
                    <span class="room-btn-label">${room.name}</span>
                </button>`;
            }
            html += '</nav>';
            return html;
        }

        function switchRoom(roomId) {
            if (!ROOMS[roomId] || roomId === gameState.currentRoom) return;

            gameState.currentRoom = roomId;
            saveGame();

            const room = ROOMS[roomId];
            const petArea = document.querySelector('.pet-area');

            if (petArea) {
                // Update room class
                ROOM_IDS.forEach(id => petArea.classList.remove('room-' + id));
                petArea.classList.add('room-' + roomId);

                // Update background
                petArea.style.background = getRoomBackground(roomId, gameState.timeOfDay);

                // Update room decor
                const decor = petArea.querySelector('.room-decor');
                if (decor) {
                    decor.textContent = getRoomDecor(roomId, gameState.timeOfDay);
                }

                // Update room label
                const label = petArea.querySelector('.room-label');
                if (label) {
                    label.textContent = room.icon + ' ' + room.name;
                }

                // Show/hide outdoor elements based on room type
                const isOutdoor = room.isOutdoor;
                petArea.querySelectorAll('.cloud').forEach(c => c.style.display = isOutdoor ? '' : 'none');
                const sun = petArea.querySelector('.sun');
                if (sun) sun.style.display = isOutdoor ? '' : 'none';
                const starsOverlay = petArea.querySelector('.stars-overlay');
                if (starsOverlay) starsOverlay.style.display = isOutdoor ? '' : 'none';
                const moon = petArea.querySelector('.moon');
                if (moon) moon.style.display = isOutdoor ? '' : 'none';

                // Update weather display for the new room
                updateWeatherDisplay();
            }

            // Update mood display since weather affects mood differently indoors/outdoors
            updatePetMood();

            // Update nav buttons
            document.querySelectorAll('.room-btn').forEach(btn => {
                const isActive = btn.dataset.room === roomId;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-pressed', isActive);
                if (isActive) {
                    btn.setAttribute('aria-current', 'true');
                } else {
                    btn.removeAttribute('aria-current');
                }
            });

            announce(`Moved to the ${room.name}!`);
        }

        // ==================== SVG GENERATION ====================

        function generateEggSVG(crackLevel) {
            const cracks = [];
            if (crackLevel >= 1) {
                cracks.push('<path class="egg-crack" style="opacity:1" d="M55 40 L60 55 L50 50 Z" fill="#8B7355" stroke="#5D4037" stroke-width="1"/>');
            }
            if (crackLevel >= 2) {
                cracks.push('<path class="egg-crack" style="opacity:1" d="M65 60 L75 75 L60 70 Z" fill="#8B7355" stroke="#5D4037" stroke-width="1"/>');
            }
            if (crackLevel >= 3) {
                cracks.push('<path class="egg-crack" style="opacity:1" d="M45 70 L40 85 L55 80 Z" fill="#8B7355" stroke="#5D4037" stroke-width="1"/>');
            }

            return `
                <svg class="egg-svg" viewBox="0 0 100 130" role="img" aria-label="A colorful egg waiting to hatch. Tap to help it hatch!">
                    <defs>
                        <linearGradient id="eggGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#FFE4B5"/>
                            <stop offset="50%" style="stop-color:#FFDAB9"/>
                            <stop offset="100%" style="stop-color:#FFE4B5"/>
                        </linearGradient>
                        <linearGradient id="eggShine" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:rgba(255,255,255,0.6)"/>
                            <stop offset="100%" style="stop-color:rgba(255,255,255,0)"/>
                        </linearGradient>
                    </defs>
                    <!-- Egg body -->
                    <ellipse cx="50" cy="70" rx="40" ry="50" fill="url(#eggGradient)" stroke="#DEB887" stroke-width="3"/>
                    <!-- Decorative spots -->
                    <circle cx="35" cy="50" r="8" fill="#FFB6C1" opacity="0.7"/>
                    <circle cx="65" cy="45" r="6" fill="#87CEEB" opacity="0.7"/>
                    <circle cx="55" cy="80" r="7" fill="#98FB98" opacity="0.7"/>
                    <circle cx="30" cy="75" r="5" fill="#DDA0DD" opacity="0.7"/>
                    <circle cx="70" cy="70" r="6" fill="#FFD700" opacity="0.7"/>
                    <!-- Shine -->
                    <ellipse cx="35" cy="45" rx="15" ry="20" fill="url(#eggShine)"/>
                    <!-- Cracks -->
                    ${cracks.join('')}
                </svg>
            `;
        }

        function generatePetSVG(pet, mood) {
            const type = pet.type;
            const color = pet.color;

            // Eye style based on mood
            let eyeStyle = '';
            let mouthPath = '';

            switch (mood) {
                case 'happy':
                    eyeStyle = 'arc'; // Happy curved eyes
                    mouthPath = 'M35 75 Q50 90 65 75'; // Big smile
                    break;
                case 'neutral':
                    eyeStyle = 'normal';
                    mouthPath = 'M40 78 L60 78'; // Straight line
                    break;
                case 'sad':
                    eyeStyle = 'sad';
                    mouthPath = 'M35 82 Q50 72 65 82'; // Frown
                    break;
                case 'sleepy':
                    eyeStyle = 'sleepy'; // Half-closed droopy eyes
                    mouthPath = 'M40 80 Q50 84 60 80'; // Gentle yawn/open mouth
                    break;
                case 'energetic':
                    eyeStyle = 'energetic'; // Wide bright eyes
                    mouthPath = 'M35 75 Q50 92 65 75'; // Big excited smile
                    break;
            }

            const petSVGs = {
                dog: generateDogSVG(color, eyeStyle, mouthPath, mood),
                cat: generateCatSVG(color, eyeStyle, mouthPath, mood),
                bunny: generateBunnySVG(color, eyeStyle, mouthPath, mood),
                bird: generateBirdSVG(color, eyeStyle, mouthPath, mood),
                hamster: generateHamsterSVG(color, eyeStyle, mouthPath, mood),
                turtle: generateTurtleSVG(color, eyeStyle, mouthPath, mood)
            };

            return petSVGs[type] || petSVGs.dog;
        }

        function generateEyes(eyeStyle, leftX, rightX, y) {
            switch (eyeStyle) {
                case 'arc':
                    return `
                        <path d="M${leftX - 5} ${y} Q${leftX} ${y - 8} ${leftX + 5} ${y}" stroke="#333" stroke-width="3" fill="none" stroke-linecap="round"/>
                        <path d="M${rightX - 5} ${y} Q${rightX} ${y - 8} ${rightX + 5} ${y}" stroke="#333" stroke-width="3" fill="none" stroke-linecap="round"/>
                    `;
                case 'sad':
                    return `
                        <circle cx="${leftX}" cy="${y}" r="5" fill="#333"/>
                        <circle cx="${rightX}" cy="${y}" r="5" fill="#333"/>
                        <circle cx="${leftX + 1}" cy="${y - 1}" r="1.5" fill="white"/>
                        <circle cx="${rightX + 1}" cy="${y - 1}" r="1.5" fill="white"/>
                        <path d="M${leftX - 6} ${y - 8} L${leftX + 4} ${y - 5}" stroke="#333" stroke-width="2" stroke-linecap="round"/>
                        <path d="M${rightX + 6} ${y - 8} L${rightX - 4} ${y - 5}" stroke="#333" stroke-width="2" stroke-linecap="round"/>
                    `;
                case 'sleepy':
                    // Half-closed droopy eyes with eyelids
                    return `
                        <ellipse cx="${leftX}" cy="${y}" rx="5" ry="3" fill="#333"/>
                        <ellipse cx="${rightX}" cy="${y}" rx="5" ry="3" fill="#333"/>
                        <circle cx="${leftX + 1}" cy="${y}" r="1" fill="white" opacity="0.5"/>
                        <circle cx="${rightX + 1}" cy="${y}" r="1" fill="white" opacity="0.5"/>
                        <path d="M${leftX - 6} ${y - 4} Q${leftX} ${y - 6} ${leftX + 6} ${y - 4}" stroke="#333" stroke-width="2.5" fill="none" stroke-linecap="round"/>
                        <path d="M${rightX - 6} ${y - 4} Q${rightX} ${y - 6} ${rightX + 6} ${y - 4}" stroke="#333" stroke-width="2.5" fill="none" stroke-linecap="round"/>
                    `;
                case 'energetic':
                    // Wide, bright, sparkling eyes
                    return `
                        <circle cx="${leftX}" cy="${y}" r="7" fill="#333"/>
                        <circle cx="${rightX}" cy="${y}" r="7" fill="#333"/>
                        <circle cx="${leftX + 2}" cy="${y - 2}" r="3" fill="white"/>
                        <circle cx="${rightX + 2}" cy="${y - 2}" r="3" fill="white"/>
                        <circle cx="${leftX - 1}" cy="${y + 2}" r="1.5" fill="white" opacity="0.7"/>
                        <circle cx="${rightX - 1}" cy="${y + 2}" r="1.5" fill="white" opacity="0.7"/>
                    `;
                default:
                    return `
                        <circle cx="${leftX}" cy="${y}" r="6" fill="#333"/>
                        <circle cx="${rightX}" cy="${y}" r="6" fill="#333"/>
                        <circle cx="${leftX + 2}" cy="${y - 2}" r="2" fill="white"/>
                        <circle cx="${rightX + 2}" cy="${y - 2}" r="2" fill="white"/>
                    `;
            }
        }

        function generateDogSVG(color, eyeStyle, mouthPath, mood) {
            const isUp = mood === 'happy' || mood === 'energetic';
            const ariaLabel = mood === 'happy' ? 'A happy puppy wagging its tail' : mood === 'sad' ? 'A sad puppy who needs love' : mood === 'sleepy' ? 'A sleepy puppy ready for bed' : mood === 'energetic' ? 'An energetic puppy ready to play' : 'A calm puppy';
            return `
                <svg class="pet-svg" viewBox="0 0 100 100" role="img" aria-label="${ariaLabel}">
                    <!-- Body -->
                    <ellipse cx="50" cy="70" rx="30" ry="25" fill="${color}"/>
                    <!-- Head -->
                    <circle cx="50" cy="40" r="25" fill="${color}"/>
                    <!-- Ears -->
                    <ellipse cx="25" cy="30" rx="10" ry="18" fill="${color}" transform="rotate(-20 25 30)"/>
                    <ellipse cx="75" cy="30" rx="10" ry="18" fill="${color}" transform="rotate(20 75 30)"/>
                    <!-- Inner ears -->
                    <ellipse cx="25" cy="32" rx="5" ry="10" fill="#FFB6C1" transform="rotate(-20 25 32)"/>
                    <ellipse cx="75" cy="32" rx="5" ry="10" fill="#FFB6C1" transform="rotate(20 75 32)"/>
                    <!-- Snout -->
                    <ellipse cx="50" cy="50" rx="12" ry="10" fill="#F5DEB3"/>
                    <!-- Nose -->
                    <ellipse cx="50" cy="48" rx="5" ry="4" fill="#333"/>
                    <!-- Eyes -->
                    ${generateEyes(eyeStyle, 38, 62, 38)}
                    <!-- Mouth -->
                    <path d="${mouthPath}" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                    <!-- Tail -->
                    <path d="M80 70 Q95 ${isUp ? '50' : '65'} 85 ${isUp ? '45' : '60'}" stroke="${color}" stroke-width="8" fill="none" stroke-linecap="round"/>
                    <!-- Cheeks -->
                    ${isUp ? '<circle cx="30" cy="48" r="5" fill="#FFB6C1" opacity="0.5"/><circle cx="70" cy="48" r="5" fill="#FFB6C1" opacity="0.5"/>' : ''}
                    <!-- Sleepy Zzz -->
                    ${mood === 'sleepy' ? '<text x="75" y="25" font-size="12" fill="#6666aa" opacity="0.8">z</text><text x="82" y="18" font-size="9" fill="#6666aa" opacity="0.6">z</text><text x="87" y="12" font-size="7" fill="#6666aa" opacity="0.4">z</text>' : ''}
                </svg>
            `;
        }

        function generateCatSVG(color, eyeStyle, mouthPath, mood) {
            const isUp = mood === 'happy' || mood === 'energetic';
            const ariaLabel = mood === 'happy' ? 'A happy kitty purring' : mood === 'sad' ? 'A sad kitty who needs love' : mood === 'sleepy' ? 'A sleepy kitty curling up' : mood === 'energetic' ? 'An energetic kitty ready to pounce' : 'A calm kitty';
            // Cat has custom eyes - handle sleepy/energetic
            let catEyes = '';
            if (eyeStyle === 'arc') {
                catEyes = `<path d="M33 38 Q38 30 43 38" stroke="#333" stroke-width="3" fill="none" stroke-linecap="round"/>
                     <path d="M57 38 Q62 30 67 38" stroke="#333" stroke-width="3" fill="none" stroke-linecap="round"/>`;
            } else if (eyeStyle === 'sad') {
                catEyes = `<ellipse cx="38" cy="38" rx="5" ry="7" fill="#90EE90"/>
                     <ellipse cx="62" cy="38" rx="5" ry="7" fill="#90EE90"/>
                     <ellipse cx="38" cy="39" rx="2" ry="5" fill="#333"/>
                     <ellipse cx="62" cy="39" rx="2" ry="5" fill="#333"/>
                     <path d="M32 32 L42 35" stroke="#333" stroke-width="2" stroke-linecap="round"/>
                     <path d="M68 32 L58 35" stroke="#333" stroke-width="2" stroke-linecap="round"/>`;
            } else if (eyeStyle === 'sleepy') {
                catEyes = `<ellipse cx="38" cy="38" rx="5" ry="3" fill="#90EE90"/>
                     <ellipse cx="62" cy="38" rx="5" ry="3" fill="#90EE90"/>
                     <ellipse cx="38" cy="38" rx="2" ry="2" fill="#333"/>
                     <ellipse cx="62" cy="38" rx="2" ry="2" fill="#333"/>
                     <path d="M33 35 Q38 33 43 35" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                     <path d="M57 35 Q62 33 67 35" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>`;
            } else if (eyeStyle === 'energetic') {
                catEyes = `<ellipse cx="38" cy="38" rx="6" ry="8" fill="#90EE90"/>
                     <ellipse cx="62" cy="38" rx="6" ry="8" fill="#90EE90"/>
                     <ellipse cx="38" cy="38" rx="2" ry="6" fill="#333"/>
                     <ellipse cx="62" cy="38" rx="2" ry="6" fill="#333"/>
                     <circle cx="36" cy="35" r="2" fill="white" opacity="0.8"/>
                     <circle cx="60" cy="35" r="2" fill="white" opacity="0.8"/>`;
            } else {
                catEyes = `<ellipse cx="38" cy="38" rx="5" ry="7" fill="#90EE90"/>
                     <ellipse cx="62" cy="38" rx="5" ry="7" fill="#90EE90"/>
                     <ellipse cx="38" cy="39" rx="2" ry="5" fill="#333"/>
                     <ellipse cx="62" cy="39" rx="2" ry="5" fill="#333"/>`;
            }
            return `
                <svg class="pet-svg" viewBox="0 0 100 100" role="img" aria-label="${ariaLabel}">
                    <!-- Body -->
                    <ellipse cx="50" cy="72" rx="28" ry="23" fill="${color}"/>
                    <!-- Head -->
                    <circle cx="50" cy="40" r="24" fill="${color}"/>
                    <!-- Ears (triangles) -->
                    <polygon points="25,35 20,10 40,25" fill="${color}"/>
                    <polygon points="75,35 80,10 60,25" fill="${color}"/>
                    <!-- Inner ears -->
                    <polygon points="27,32 24,18 36,27" fill="#FFB6C1"/>
                    <polygon points="73,32 76,18 64,27" fill="#FFB6C1"/>
                    <!-- Eyes -->
                    ${catEyes}
                    <!-- Nose -->
                    <polygon points="50,48 46,44 54,44" fill="#FFB6C1"/>
                    <!-- Mouth -->
                    <path d="${mouthPath}" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                    <!-- Whiskers -->
                    <line x1="20" y1="48" x2="35" y2="50" stroke="#333" stroke-width="1"/>
                    <line x1="20" y1="52" x2="35" y2="52" stroke="#333" stroke-width="1"/>
                    <line x1="65" y1="50" x2="80" y2="48" stroke="#333" stroke-width="1"/>
                    <line x1="65" y1="52" x2="80" y2="52" stroke="#333" stroke-width="1"/>
                    <!-- Tail -->
                    <path d="M78 72 Q100 60 95 ${isUp ? '40' : '55'}" stroke="${color}" stroke-width="8" fill="none" stroke-linecap="round"/>
                    <!-- Cheeks -->
                    ${isUp ? '<circle cx="28" cy="48" r="5" fill="#FFB6C1" opacity="0.5"/><circle cx="72" cy="48" r="5" fill="#FFB6C1" opacity="0.5"/>' : ''}
                    <!-- Sleepy Zzz -->
                    ${mood === 'sleepy' ? '<text x="75" y="25" font-size="12" fill="#6666aa" opacity="0.8">z</text><text x="82" y="18" font-size="9" fill="#6666aa" opacity="0.6">z</text><text x="87" y="12" font-size="7" fill="#6666aa" opacity="0.4">z</text>' : ''}
                </svg>
            `;
        }

        function generateBunnySVG(color, eyeStyle, mouthPath, mood) {
            const isUp = mood === 'happy' || mood === 'energetic';
            // Bunny-specific mouth paths (adjusted for bunny face position)
            let bunnyMouth = '';
            if (mood === 'happy' || mood === 'energetic') {
                bunnyMouth = '<path d="M46 56 L50 62 L54 56" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>';
            } else if (mood === 'sad') {
                bunnyMouth = '<path d="M46 60 Q50 55 54 60" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>';
            } else if (mood === 'sleepy') {
                bunnyMouth = '<ellipse cx="50" cy="58" rx="3" ry="4" fill="#333" opacity="0.6"/>';  // Yawning mouth
            } else {
                bunnyMouth = '<path d="M46 58 L54 58" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>';
            }

            const ariaLabel = mood === 'happy' ? 'A happy bunny hopping with joy' : mood === 'sad' ? 'A sad bunny who needs love' : mood === 'sleepy' ? 'A sleepy bunny nesting down' : mood === 'energetic' ? 'An energetic bunny bouncing around' : 'A calm bunny';
            return `
                <svg class="pet-svg" viewBox="0 0 100 100" role="img" aria-label="${ariaLabel}">
                    <!-- Body -->
                    <ellipse cx="50" cy="75" rx="25" ry="20" fill="${color}"/>
                    <!-- Head -->
                    <circle cx="50" cy="45" r="22" fill="${color}"/>
                    <!-- Ears (long) -->
                    <ellipse cx="35" cy="${mood === 'sleepy' ? '18' : '15'}" rx="8" ry="25" fill="${color}" ${mood === 'sleepy' ? 'transform="rotate(10 35 18)"' : ''}/>
                    <ellipse cx="65" cy="${mood === 'sleepy' ? '18' : '15'}" rx="8" ry="25" fill="${color}" ${mood === 'sleepy' ? 'transform="rotate(-10 65 18)"' : ''}/>
                    <!-- Inner ears -->
                    <ellipse cx="35" cy="${mood === 'sleepy' ? '18' : '15'}" rx="4" ry="18" fill="#FFB6C1" ${mood === 'sleepy' ? 'transform="rotate(10 35 18)"' : ''}/>
                    <ellipse cx="65" cy="${mood === 'sleepy' ? '18' : '15'}" rx="4" ry="18" fill="#FFB6C1" ${mood === 'sleepy' ? 'transform="rotate(-10 65 18)"' : ''}/>
                    <!-- Eyes -->
                    ${generateEyes(eyeStyle, 40, 60, 42)}
                    <!-- Nose -->
                    <ellipse cx="50" cy="52" rx="4" ry="3" fill="#FFB6C1"/>
                    <!-- Mouth -->
                    ${bunnyMouth}
                    <!-- Cheeks -->
                    <circle cx="32" cy="52" r="6" fill="#FFB6C1" opacity="${isUp ? '0.7' : '0.5'}"/>
                    <circle cx="68" cy="52" r="6" fill="#FFB6C1" opacity="${isUp ? '0.7' : '0.5'}"/>
                    <!-- Feet -->
                    <ellipse cx="35" cy="92" rx="10" ry="6" fill="${color}"/>
                    <ellipse cx="65" cy="92" rx="10" ry="6" fill="${color}"/>
                    <!-- Tail (fluffy ball) -->
                    <circle cx="75" cy="80" r="8" fill="white"/>
                    <!-- Sleepy Zzz -->
                    ${mood === 'sleepy' ? '<text x="75" y="30" font-size="12" fill="#6666aa" opacity="0.8">z</text><text x="82" y="23" font-size="9" fill="#6666aa" opacity="0.6">z</text><text x="87" y="17" font-size="7" fill="#6666aa" opacity="0.4">z</text>' : ''}
                </svg>
            `;
        }

        function generateBirdSVG(color, eyeStyle, mouthPath, mood) {
            const isUp = mood === 'happy' || mood === 'energetic';
            const ariaLabel = mood === 'happy' ? 'A happy bird singing' : mood === 'sad' ? 'A sad bird who needs love' : mood === 'sleepy' ? 'A sleepy bird tucking its head' : mood === 'energetic' ? 'An energetic bird chirping loudly' : 'A calm bird';
            return `
                <svg class="pet-svg" viewBox="0 0 100 100" role="img" aria-label="${ariaLabel}">
                    <!-- Body -->
                    <ellipse cx="50" cy="65" rx="25" ry="28" fill="${color}"/>
                    <!-- Head -->
                    <circle cx="50" cy="32" r="20" fill="${color}"/>
                    <!-- Wing -->
                    <ellipse cx="30" cy="65" rx="15" ry="20" fill="${color}" opacity="0.8"/>
                    <ellipse cx="70" cy="65" rx="15" ry="20" fill="${color}" opacity="0.8"/>
                    <!-- Belly -->
                    <ellipse cx="50" cy="70" rx="15" ry="18" fill="#F5F5DC"/>
                    <!-- Eyes -->
                    ${generateEyes(eyeStyle, 42, 58, 30)}
                    <!-- Beak -->
                    <polygon points="50,38 42,45 50,48 58,45" fill="#FFA500"/>
                    <!-- Tuft -->
                    <ellipse cx="50" cy="14" rx="5" ry="8" fill="${color}"/>
                    <ellipse cx="45" cy="16" rx="4" ry="6" fill="${color}"/>
                    <ellipse cx="55" cy="16" rx="4" ry="6" fill="${color}"/>
                    <!-- Feet -->
                    <line x1="42" y1="90" x2="42" y2="98" stroke="#FFA500" stroke-width="3"/>
                    <line x1="50" y1="92" x2="50" y2="98" stroke="#FFA500" stroke-width="3"/>
                    <line x1="58" y1="90" x2="58" y2="98" stroke="#FFA500" stroke-width="3"/>
                    <!-- Cheeks -->
                    ${isUp ? '<circle cx="35" cy="38" r="4" fill="#FFB6C1" opacity="0.6"/><circle cx="65" cy="38" r="4" fill="#FFB6C1" opacity="0.6"/>' : ''}
                    <!-- Sleepy Zzz -->
                    ${mood === 'sleepy' ? '<text x="70" y="18" font-size="12" fill="#6666aa" opacity="0.8">z</text><text x="77" y="11" font-size="9" fill="#6666aa" opacity="0.6">z</text><text x="82" y="6" font-size="7" fill="#6666aa" opacity="0.4">z</text>' : ''}
                </svg>
            `;
        }

        function generateHamsterSVG(color, eyeStyle, mouthPath, mood) {
            const ariaLabel = mood === 'happy' ? 'A happy hamster running on its wheel' : mood === 'sad' ? 'A sad hamster who needs love' : mood === 'sleepy' ? 'A sleepy hamster curling up in its bedding' : mood === 'energetic' ? 'An energetic hamster zooming around' : 'A calm hamster';
            return `
                <svg class="pet-svg" viewBox="0 0 100 100" role="img" aria-label="${ariaLabel}">
                    <!-- Body -->
                    <ellipse cx="50" cy="70" rx="30" ry="25" fill="${color}"/>
                    <!-- Head -->
                    <circle cx="50" cy="40" r="28" fill="${color}"/>
                    <!-- Ears -->
                    <circle cx="25" cy="22" r="10" fill="${color}"/>
                    <circle cx="75" cy="22" r="10" fill="${color}"/>
                    <!-- Inner ears -->
                    <circle cx="25" cy="22" r="5" fill="#FFB6C1"/>
                    <circle cx="75" cy="22" r="5" fill="#FFB6C1"/>
                    <!-- Cheeks (puffy) -->
                    <circle cx="28" cy="48" r="12" fill="#FFE4C4"/>
                    <circle cx="72" cy="48" r="12" fill="#FFE4C4"/>
                    <!-- Eyes -->
                    ${generateEyes(eyeStyle, 40, 60, 38)}
                    <!-- Nose -->
                    <circle cx="50" cy="50" r="4" fill="#333"/>
                    <!-- Mouth -->
                    <path d="${mouthPath}" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                    <!-- Whiskers -->
                    <line x1="15" y1="48" x2="28" y2="50" stroke="#333" stroke-width="1"/>
                    <line x1="15" y1="52" x2="28" y2="52" stroke="#333" stroke-width="1"/>
                    <line x1="72" y1="50" x2="85" y2="48" stroke="#333" stroke-width="1"/>
                    <line x1="72" y1="52" x2="85" y2="52" stroke="#333" stroke-width="1"/>
                    <!-- Paws -->
                    <ellipse cx="30" cy="88" rx="8" ry="5" fill="${color}"/>
                    <ellipse cx="70" cy="88" rx="8" ry="5" fill="${color}"/>
                    <!-- Belly -->
                    <ellipse cx="50" cy="72" rx="18" ry="15" fill="#F5F5DC"/>
                    <!-- Sleepy Zzz -->
                    ${mood === 'sleepy' ? '<text x="78" y="25" font-size="12" fill="#6666aa" opacity="0.8">z</text><text x="85" y="18" font-size="9" fill="#6666aa" opacity="0.6">z</text><text x="90" y="12" font-size="7" fill="#6666aa" opacity="0.4">z</text>' : ''}
                </svg>
            `;
        }

        function generateTurtleSVG(color, eyeStyle, mouthPath, mood) {
            const isUp = mood === 'happy' || mood === 'energetic';
            const ariaLabel = mood === 'happy' ? 'A happy turtle basking in the sun' : mood === 'sad' ? 'A sad turtle hiding in its shell' : mood === 'sleepy' ? 'A sleepy turtle retreating into its shell' : mood === 'energetic' ? 'An energetic turtle stretching out' : 'A calm turtle';
            return `
                <svg class="pet-svg" viewBox="0 0 100 100" role="img" aria-label="${ariaLabel}">
                    <!-- Shell -->
                    <ellipse cx="50" cy="60" rx="38" ry="30" fill="${color}"/>
                    <!-- Shell pattern -->
                    <ellipse cx="50" cy="55" rx="25" ry="18" fill="none" stroke="#2E7D32" stroke-width="2"/>
                    <path d="M50 37 L50 73" stroke="#2E7D32" stroke-width="2"/>
                    <path d="M25 55 L75 55" stroke="#2E7D32" stroke-width="2"/>
                    <path d="M30 42 L70 68" stroke="#2E7D32" stroke-width="2"/>
                    <path d="M30 68 L70 42" stroke="#2E7D32" stroke-width="2"/>
                    <!-- Shell rim -->
                    <ellipse cx="50" cy="60" rx="38" ry="30" fill="none" stroke="#1B5E20" stroke-width="3"/>
                    <!-- Head -->
                    <ellipse cx="50" cy="28" rx="15" ry="12" fill="#8FBC8F"/>
                    <!-- Eyes -->
                    ${generateEyes(eyeStyle, 44, 56, 26)}
                    <!-- Mouth -->
                    <path d="M45 33 Q50 ${isUp ? '38' : '35'} 55 33" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round"/>
                    <!-- Legs -->
                    <ellipse cx="20" cy="55" rx="10" ry="8" fill="#8FBC8F"/>
                    <ellipse cx="80" cy="55" rx="10" ry="8" fill="#8FBC8F"/>
                    <ellipse cx="25" cy="80" rx="8" ry="10" fill="#8FBC8F"/>
                    <ellipse cx="75" cy="80" rx="8" ry="10" fill="#8FBC8F"/>
                    <!-- Tail -->
                    <ellipse cx="50" cy="92" rx="6" ry="4" fill="#8FBC8F"/>
                    <!-- Cheeks -->
                    ${isUp ? '<circle cx="38" cy="30" r="3" fill="#FFB6C1" opacity="0.5"/><circle cx="62" cy="30" r="3" fill="#FFB6C1" opacity="0.5"/>' : ''}
                    <!-- Sleepy Zzz -->
                    ${mood === 'sleepy' ? '<text x="68" y="18" font-size="12" fill="#6666aa" opacity="0.8">z</text><text x="75" y="11" font-size="9" fill="#6666aa" opacity="0.6">z</text><text x="80" y="6" font-size="7" fill="#6666aa" opacity="0.4">z</text>' : ''}
                </svg>
            `;
        }

        // ==================== RENDER FUNCTIONS ====================

        function renderEggPhase(maintainFocus = false) {
            const content = document.getElementById('game-content');
            const crackLevel = Math.min(gameState.eggTaps, 3);

            // Generate progress dots
            let progressDots = '';
            for (let i = 0; i < 5; i++) {
                progressDots += `<div class="egg-progress-dot ${i < gameState.eggTaps ? 'filled' : ''}" aria-hidden="true"></div>`;
            }

            content.innerHTML = `
                <div class="pet-area" role="region" aria-label="Egg hatching area">
                    <div class="sparkles" id="sparkles"></div>
                    <button class="egg-container" id="egg-button"
                            aria-label="Tap the egg to help it hatch! Tapped ${gameState.eggTaps} of 5 times. ${5 - gameState.eggTaps} more taps needed."
                            aria-describedby="tap-hint">
                        ${generateEggSVG(crackLevel)}
                    </button>
                    <p class="hatch-message" aria-live="polite">A mystery pet is inside!</p>
                    <div class="egg-progress" role="progressbar" aria-valuenow="${gameState.eggTaps}" aria-valuemin="0" aria-valuemax="5" aria-label="Hatching progress: ${gameState.eggTaps} of 5 taps">
                        ${progressDots}
                    </div>
                    <p class="tap-hint" id="tap-hint">Tap the egg to hatch it!</p>
                </div>
            `;

            const eggButton = document.getElementById('egg-button');

            // Use named function to allow proper removal if needed
            function onEggClick(e) {
                e.preventDefault();
                handleEggTap();
            }

            function onEggKeydown(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleEggTap();
                }
            }

            eggButton.addEventListener('click', onEggClick);
            eggButton.addEventListener('keydown', onEggKeydown);

            // Maintain focus for keyboard users
            if (maintainFocus) {
                eggButton.focus();
            }
        }

        // Prevent rapid tapping issues
        let eggTapCooldown = false;

        function handleEggTap() {
            if (eggTapCooldown) return;

            eggTapCooldown = true;
            setTimeout(() => { eggTapCooldown = false; }, 200);

            gameState.eggTaps++;
            const eggButton = document.getElementById('egg-button');
            const sparkles = document.getElementById('sparkles');

            // Add shake animation
            eggButton.classList.add('egg-shake');
            setTimeout(() => eggButton.classList.remove('egg-shake'), 300);

            // Add sparkles
            createSparkles(sparkles, 5);

            // Announce progress
            const remaining = 5 - gameState.eggTaps;
            if (remaining > 0) {
                announce(`Tap ${gameState.eggTaps} of 5. ${remaining} more to hatch!`);
            }

            if (gameState.eggTaps >= 5) {
                // Hatch the egg!
                gameState.phase = 'hatching';
                announce('The egg is hatching! Here comes your pet!', true);
                setTimeout(hatchPet, 1000);
            } else {
                // Update egg display with more cracks, maintain focus for keyboard users
                renderEggPhase(true);
            }

            saveGame();
        }

        function hatchPet() {
            // Reset egg tap cooldown
            eggTapCooldown = false;

            gameState.pet = createPet();
            gameState.phase = 'pet';
            saveGame();

            const petData = PET_TYPES[gameState.pet.type];
            announce(`Congratulations! You hatched a ${petData.name}! ${petData.emoji}`, true);

            showNamingModal(petData);
        }

        function showNamingModal(petData) {
            const overlay = document.createElement('div');
            overlay.className = 'naming-overlay';
            overlay.innerHTML = `
                <div class="naming-modal">
                    <div class="naming-modal-icon">${petData.emoji}</div>
                    <h2 class="naming-modal-title">You hatched a ${petData.name}!</h2>
                    <p class="naming-modal-subtitle">Give your new pet a name</p>
                    <input type="text" class="naming-input" id="pet-name-input"
                           placeholder="${petData.name}" maxlength="14" autocomplete="off"
                           aria-label="Enter a name for your pet">
                    <button class="naming-submit-btn" id="naming-submit">Choose Name</button>
                    <button class="naming-skip-btn" id="naming-skip">Keep "${petData.name}"</button>
                </div>
            `;
            document.body.appendChild(overlay);

            const input = document.getElementById('pet-name-input');
            const submitBtn = document.getElementById('naming-submit');
            const skipBtn = document.getElementById('naming-skip');

            setTimeout(() => input.focus(), 100);

            function finishNaming(customName) {
                const name = customName ? customName.trim() : '';
                if (name.length > 0) {
                    gameState.pet.name = name;
                } else {
                    gameState.pet.name = petData.name;
                }
                saveGame();
                overlay.remove();
                renderPetPhase();
                showToast(`Welcome home, ${gameState.pet.name}!`, '#4ECDC4');
            }

            submitBtn.addEventListener('click', () => finishNaming(input.value));
            skipBtn.addEventListener('click', () => finishNaming(''));
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finishNaming(input.value);
            });
        }

        function renderPetPhase() {
            const content = document.getElementById('game-content');
            const pet = gameState.pet;
            const petData = PET_TYPES[pet.type];
            const mood = getMood(pet);
            const moodMessage = randomFromArray(MOOD_MESSAGES[mood]);

            // Update time of day
            gameState.timeOfDay = getTimeOfDay();
            const timeOfDay = gameState.timeOfDay;
            const timeIcon = getTimeIcon(timeOfDay);
            const timeClass = timeOfDay === 'day' ? 'daytime' : timeOfDay === 'night' ? 'nighttime' : timeOfDay;

            // Current room
            const currentRoom = gameState.currentRoom || 'bedroom';
            const room = ROOMS[currentRoom];
            const isOutdoor = room.isOutdoor;
            const roomBg = getRoomBackground(currentRoom, timeOfDay);
            const roomDecor = getRoomDecor(currentRoom, timeOfDay);

            // Generate celestial elements (only for outdoor rooms)
            let celestialHTML = '';
            if (isOutdoor) {
                if (timeOfDay === 'night') {
                    celestialHTML = `<div class="stars-overlay">${generateStarsHTML()}</div><div class="moon"></div>`;
                } else if (timeOfDay === 'day') {
                    celestialHTML = `<div class="sun"></div><div class="cloud" style="top:12px;left:-30px;">‚òÅÔ∏è</div><div class="cloud" style="top:35px;left:20%;">‚òÅÔ∏è</div>`;
                } else if (timeOfDay === 'sunrise' || timeOfDay === 'sunset') {
                    celestialHTML = `<div class="cloud" style="top:18px;left:10%;">‚òÅÔ∏è</div>`;
                }
            }

            // Generate weather effects
            const weather = gameState.weather || 'sunny';
            const weatherData = WEATHER_TYPES[weather];
            let weatherHTML = '';
            if (isOutdoor) {
                weatherHTML = generateWeatherHTML(weather);
            }
            const weatherClass = isOutdoor && weather !== 'sunny' ? `weather-${weather}` : '';
            const weatherBadgeHTML = `<div class="weather-badge ${weather}" aria-label="Weather: ${weatherData.name}">${weatherData.icon} ${weatherData.name}</div>`;

            // Weather mood note
            const weatherMoodNote = getWeatherMoodMessage(pet, weather);

            // Helper: need bubble class based on level
            function needClass(val) {
                if (val <= 15) return 'critical';
                if (val <= 25) return 'low warning';
                if (val <= 45) return 'warning';
                return '';
            }

            const petDisplayName = escapeHTML(pet.name || petData.name);

            content.innerHTML = `
                ${generateRoomNavHTML(currentRoom)}
                <div class="pet-area ${timeClass} ${weatherClass} room-${currentRoom}" role="region" aria-label="Your pet ${petDisplayName} in the ${room.name}" style="background: ${roomBg};">
                    ${celestialHTML}
                    ${weatherHTML}
                    ${weatherBadgeHTML}
                    <div class="room-label">${room.icon} ${room.name}</div>
                    <div class="time-indicator" aria-label="Time: ${timeOfDay}">${timeIcon}</div>
                    <div class="sparkles" id="sparkles"></div>
                    <div class="pet-container" id="pet-container">
                        ${generatePetSVG(pet, mood)}
                    </div>
                    <div class="pet-info">
                        <p class="pet-name">${petData.emoji} ${petDisplayName}</p>
                        <div class="mood-badge ${mood}" id="mood-badge">
                            <span class="mood-badge-emoji">${mood === 'happy' ? 'üòä' : mood === 'neutral' ? 'üòê' : 'üò¢'}</span>
                            <span>${mood === 'happy' ? 'Happy' : mood === 'neutral' ? 'Okay' : 'Sad'}</span>
                        </div>
                    </div>
                    <p class="pet-mood" id="pet-mood" aria-live="polite">${petDisplayName} ${moodMessage}${weatherMoodNote ? `<span class="weather-mood-note">${weatherData.icon} ${petDisplayName} ${weatherMoodNote}</span>` : ''}</p>
                    <div class="room-decor" aria-hidden="true">${roomDecor}</div>
                </div>

                <section class="needs-section" aria-label="Pet needs">
                    <div class="needs-row">
                        <div class="need-bubble ${needClass(pet.hunger)}" id="hunger-bubble"
                             role="progressbar" aria-label="Hunger level" aria-valuenow="${pet.hunger}" aria-valuemin="0" aria-valuemax="100"
                             style="--progress: ${pet.hunger}; --ring-color: ${getNeedColor(pet.hunger)};">
                            <div class="need-bubble-ring"></div>
                            <span class="need-bubble-icon" aria-hidden="true">üçé</span>
                            <span class="need-bubble-value" id="hunger-value">${pet.hunger}%</span>
                            <span class="need-bubble-label" aria-hidden="true">Food</span>
                        </div>
                        <div class="need-bubble ${needClass(pet.cleanliness)}" id="clean-bubble"
                             role="progressbar" aria-label="Cleanliness level" aria-valuenow="${pet.cleanliness}" aria-valuemin="0" aria-valuemax="100"
                             style="--progress: ${pet.cleanliness}; --ring-color: ${getNeedColor(pet.cleanliness)};">
                            <div class="need-bubble-ring"></div>
                            <span class="need-bubble-icon" aria-hidden="true">üõÅ</span>
                            <span class="need-bubble-value" id="clean-value">${pet.cleanliness}%</span>
                            <span class="need-bubble-label" aria-hidden="true">Bath</span>
                        </div>
                        <div class="need-bubble ${needClass(pet.happiness)}" id="happy-bubble"
                             role="progressbar" aria-label="Happiness level" aria-valuenow="${pet.happiness}" aria-valuemin="0" aria-valuemax="100"
                             style="--progress: ${pet.happiness}; --ring-color: ${getNeedColor(pet.happiness)};">
                            <div class="need-bubble-ring"></div>
                            <span class="need-bubble-icon" aria-hidden="true">üíñ</span>
                            <span class="need-bubble-value" id="happy-value">${pet.happiness}%</span>
                            <span class="need-bubble-label" aria-hidden="true">Happy</span>
                        </div>
                        <div class="need-bubble ${needClass(pet.energy)}" id="energy-bubble"
                             role="progressbar" aria-label="Energy level" aria-valuenow="${pet.energy}" aria-valuemin="0" aria-valuemax="100"
                             style="--progress: ${pet.energy}; --ring-color: ${getNeedColor(pet.energy)};">
                            <div class="need-bubble-ring"></div>
                            <span class="need-bubble-icon" aria-hidden="true">üò¥</span>
                            <span class="need-bubble-value" id="energy-value">${pet.energy}%</span>
                            <span class="need-bubble-label" aria-hidden="true">Energy</span>
                        </div>
                    </div>
                </section>

                <div class="feedback-area">
                    <p class="feedback-message" id="feedback" aria-live="polite"></p>
                </div>

                <section class="actions-section" aria-label="Care actions">
                    <div class="action-group">
                        <div class="action-group-label">Basics</div>
                        <div class="action-group-buttons" role="group" aria-label="Basic care buttons">
                            <button class="action-btn feed" id="feed-btn" aria-label="Feed your pet. Current hunger: ${pet.hunger}%">
                                <span class="btn-icon" aria-hidden="true">üçé</span>
                                <span>Feed</span>
                            </button>
                            <button class="action-btn wash" id="wash-btn" aria-label="Wash your pet. Current cleanliness: ${pet.cleanliness}%">
                                <span class="btn-icon" aria-hidden="true">üõÅ</span>
                                <span>Wash</span>
                            </button>
                            <button class="action-btn sleep" id="sleep-btn" aria-label="Put your pet to sleep. Current energy: ${pet.energy}%">
                                <span class="btn-icon" aria-hidden="true">üõèÔ∏è</span>
                                <span>Sleep</span>
                            </button>
                            <button class="action-btn pet-cuddle" id="pet-btn" aria-label="Pet and cuddle your pet. Current happiness: ${pet.happiness}%">
                                <span class="btn-icon" aria-hidden="true">ü§ó</span>
                                <span>Pet</span>
                            </button>
                        </div>
                    </div>
                    <div class="action-group">
                        <div class="action-group-label">Fun & Play</div>
                        <div class="action-group-buttons" role="group" aria-label="Fun and play buttons">
                            <button class="action-btn play" id="play-btn" aria-label="Play with your pet. Current happiness: ${pet.happiness}%">
                                <span class="btn-icon" aria-hidden="true">‚öΩ</span>
                                <span>Play</span>
                            </button>
                            <button class="action-btn exercise" id="exercise-btn" aria-label="Exercise your pet - take a walk or play fetch">
                                <span class="btn-icon" aria-hidden="true">üèÉ</span>
                                <span>Exercise</span>
                            </button>
                            <button class="action-btn treat" id="treat-btn" aria-label="Give your pet a special treat for bonus happiness">
                                <span class="btn-icon" aria-hidden="true">üç™</span>
                                <span>Treat</span>
                            </button>
                            <button class="action-btn mini-games" id="minigames-btn" aria-label="Open mini games to play with your pet">
                                <span class="btn-icon" aria-hidden="true">üéÆ</span>
                                <span>Games</span>
                            </button>
                        </div>
                    </div>
                    <div class="action-group">
                        <div class="action-group-label">Wellness</div>
                        <div class="action-group-buttons" role="group" aria-label="Wellness buttons">
                            <button class="action-btn medicine" id="medicine-btn" aria-label="Give medicine to help your pet feel better">
                                <span class="btn-icon" aria-hidden="true">ü©π</span>
                                <span>Medicine</span>
                            </button>
                            <button class="action-btn groom" id="groom-btn" aria-label="Groom your pet - brush fur and trim nails">
                                <span class="btn-icon" aria-hidden="true">‚úÇÔ∏è</span>
                                <span>Groom</span>
                            </button>
                        </div>
                    </div>
                </section>

                <button class="new-pet-btn" id="new-pet-btn" aria-label="Start over with a new egg">
                    ü•ö New Pet
                </button>
            `;

            // Add event listeners
            document.getElementById('feed-btn').addEventListener('click', () => careAction('feed'));
            document.getElementById('wash-btn').addEventListener('click', () => careAction('wash'));
            document.getElementById('play-btn').addEventListener('click', () => careAction('play'));
            document.getElementById('sleep-btn').addEventListener('click', () => careAction('sleep'));
            document.getElementById('medicine-btn').addEventListener('click', () => careAction('medicine'));
            document.getElementById('groom-btn').addEventListener('click', () => careAction('groom'));
            document.getElementById('exercise-btn').addEventListener('click', () => careAction('exercise'));
            document.getElementById('treat-btn').addEventListener('click', () => careAction('treat'));
            document.getElementById('pet-btn').addEventListener('click', () => careAction('cuddle'));
            document.getElementById('minigames-btn').addEventListener('click', openMiniGamesMenu);
            document.getElementById('new-pet-btn').addEventListener('click', startNewPet);

            // Room navigation event listeners
            document.querySelectorAll('.room-btn').forEach(btn => {
                btn.addEventListener('click', () => switchRoom(btn.dataset.room));
            });

            // Make pet directly pettable by clicking/touching the pet SVG
            const petContainer = document.getElementById('pet-container');
            petContainer.classList.add('pettable');
            petContainer.setAttribute('role', 'button');
            petContainer.setAttribute('tabindex', '0');
            petContainer.setAttribute('aria-label', 'Click or tap your pet to give it cuddles!');
            petContainer.addEventListener('click', () => careAction('cuddle'));
            petContainer.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    careAction('cuddle');
                }
            });

            // Start decay timer and weather timer
            startDecayTimer();
            startWeatherTimer();
        }

        // ==================== TOAST NOTIFICATIONS ====================

        function showToast(message, color = '#66BB6A') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.style.setProperty('--toast-color', color);
            toast.textContent = message;
            container.appendChild(toast);

            // Remove after animation completes
            setTimeout(() => toast.remove(), 2500);
        }

        // Toast color map for actions
        const TOAST_COLORS = {
            feed: '#FF8C42',
            wash: '#4FC3F7',
            play: '#AED581',
            sleep: '#9575CD',
            medicine: '#F48FB1',
            groom: '#CE93D8',
            exercise: '#FFB74D',
            treat: '#FF7EB3',
            cuddle: '#FFB4A2'
        };

        // Track button cooldowns
        let actionCooldown = false;

        function careAction(action) {
            // Prevent rapid clicking
            if (actionCooldown) return;

            actionCooldown = true;
            const buttons = document.querySelectorAll('.action-btn');
            buttons.forEach(btn => btn.classList.add('cooldown'));

            setTimeout(() => {
                actionCooldown = false;
                buttons.forEach(btn => btn.classList.remove('cooldown'));
            }, 600);

            const pet = gameState.pet;
            const petData = PET_TYPES[pet.type];
            const petContainer = document.getElementById('pet-container');
            const sparkles = document.getElementById('sparkles');
            let message = '';

            switch (action) {
                case 'feed':
                    pet.hunger = clamp(pet.hunger + 20, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.feed);
                    petContainer.classList.add('bounce');
                    createFoodParticles(sparkles);
                    announce(`Fed your pet! Hunger is now ${pet.hunger}%`);
                    break;
                case 'wash':
                    pet.cleanliness = clamp(pet.cleanliness + 20, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.wash);
                    petContainer.classList.add('sparkle');
                    createBubbles(sparkles);
                    announce(`Washed your pet! Cleanliness is now ${pet.cleanliness}%`);
                    break;
                case 'play':
                    pet.happiness = clamp(pet.happiness + 20, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.play);
                    petContainer.classList.add('wiggle');
                    createHearts(sparkles);
                    announce(`Played with your pet! Happiness is now ${pet.happiness}%`);
                    break;
                case 'sleep': {
                    // Sleep is more effective at night (deep sleep) and less during the day (just a nap)
                    const sleepTime = gameState.timeOfDay || 'day';
                    let sleepBonus = 25; // default nap
                    let sleepAnnounce = 'Your pet had a nice nap!';
                    if (sleepTime === 'night') {
                        sleepBonus = 40; // deep sleep at night
                        sleepAnnounce = 'Your pet had a wonderful deep sleep!';
                    } else if (sleepTime === 'sunset') {
                        sleepBonus = 30; // good evening rest
                        sleepAnnounce = 'Your pet had a cozy evening rest!';
                    } else if (sleepTime === 'sunrise') {
                        sleepBonus = 30; // nice morning sleep-in
                        sleepAnnounce = 'Your pet slept in a little!';
                    }
                    pet.energy = clamp(pet.energy + sleepBonus, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.sleep);
                    petContainer.classList.add('sleep-anim');
                    createZzz(sparkles);
                    announce(`${sleepAnnounce} Energy is now ${pet.energy}%`);
                    break;
                }
                case 'medicine':
                    // Medicine gives a gentle boost to all stats - helps pet feel better
                    pet.hunger = clamp(pet.hunger + 10, 0, 100);
                    pet.cleanliness = clamp(pet.cleanliness + 10, 0, 100);
                    pet.happiness = clamp(pet.happiness + 15, 0, 100);
                    pet.energy = clamp(pet.energy + 10, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.medicine);
                    petContainer.classList.add('heal-anim');
                    createMedicineParticles(sparkles);
                    announce(`You gave your pet medicine! Your pet feels much better now!`);
                    break;
                case 'groom':
                    // Grooming - brush fur/feathers and trim nails
                    pet.cleanliness = clamp(pet.cleanliness + 15, 0, 100);
                    pet.happiness = clamp(pet.happiness + 10, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.groom);
                    petContainer.classList.add('groom-anim');
                    createGroomParticles(sparkles);
                    announce(`Groomed your pet! Looking beautiful and feeling happy!`);
                    break;
                case 'exercise':
                    // Exercise - take walks or play fetch
                    pet.happiness = clamp(pet.happiness + 20, 0, 100);
                    pet.energy = clamp(pet.energy - 10, 0, 100);
                    pet.hunger = clamp(pet.hunger - 5, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.exercise);
                    petContainer.classList.add('exercise-anim');
                    createExerciseParticles(sparkles);
                    announce(`Exercised your pet! Happiness is now ${pet.happiness}% but energy dropped to ${pet.energy}%`);
                    break;
                case 'treat': {
                    // Treats - special snacks that give bonus happiness
                    const treat = randomFromArray(TREAT_TYPES);
                    pet.happiness = clamp(pet.happiness + 25, 0, 100);
                    pet.hunger = clamp(pet.hunger + 10, 0, 100);
                    message = `${treat.emoji} ${randomFromArray(FEEDBACK_MESSAGES.treat)}`;
                    petContainer.classList.add('treat-anim');
                    createTreatParticles(sparkles, treat.emoji);
                    announce(`Gave your pet a ${treat.name}! Happiness is now ${pet.happiness}%`);
                    break;
                }
                case 'cuddle':
                    // Petting/Cuddling - direct affection boosts happiness and energy
                    pet.happiness = clamp(pet.happiness + 15, 0, 100);
                    pet.energy = clamp(pet.energy + 5, 0, 100);
                    message = randomFromArray(FEEDBACK_MESSAGES.cuddle);
                    petContainer.classList.add('cuddle-anim');
                    createCuddleParticles(sparkles);
                    announce(`You pet and cuddled your pet! Happiness is now ${pet.happiness}%`);
                    break;
            }

            // Show feedback
            const feedback = document.getElementById('feedback');
            feedback.textContent = `${petData.emoji} ${message}`;
            feedback.classList.add('show');

            // Show toast notification
            showToast(`${petData.emoji} ${message}`, TOAST_COLORS[action] || '#66BB6A');

            // Update displays
            updateNeedDisplays();
            updatePetMood();

            // Remove animation class
            setTimeout(() => {
                petContainer.classList.remove('bounce', 'wiggle', 'sparkle', 'sleep-anim', 'heal-anim', 'groom-anim', 'exercise-anim', 'treat-anim', 'cuddle-anim');
            }, 800);

            // Hide feedback
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 2000);

            saveGame();
        }

        function updateNeedDisplays() {
            const pet = gameState.pet;

            // Helper to update a bubble indicator with enhanced warning classes
            function updateBubble(id, value) {
                const bubble = document.getElementById(id);
                if (!bubble) return;
                bubble.style.setProperty('--progress', value);
                bubble.style.setProperty('--ring-color', getNeedColor(value));
                bubble.classList.remove('low', 'warning', 'critical');
                if (value <= 15) {
                    bubble.classList.add('critical');
                } else if (value <= 25) {
                    bubble.classList.add('low', 'warning');
                } else if (value <= 45) {
                    bubble.classList.add('warning');
                }
                bubble.setAttribute('aria-valuenow', value);
            }

            // Update circular indicators
            updateBubble('hunger-bubble', pet.hunger);
            updateBubble('clean-bubble', pet.cleanliness);
            updateBubble('happy-bubble', pet.happiness);
            updateBubble('energy-bubble', pet.energy);

            // Update values
            document.getElementById('hunger-value').textContent = `${pet.hunger}%`;
            document.getElementById('clean-value').textContent = `${pet.cleanliness}%`;
            document.getElementById('happy-value').textContent = `${pet.happiness}%`;
            document.getElementById('energy-value').textContent = `${pet.energy}%`;

            // Update button labels with more descriptive text
            const hungerDesc = pet.hunger <= 25 ? 'very low' : pet.hunger <= 50 ? 'low' : pet.hunger <= 75 ? 'good' : 'full';
            const cleanDesc = pet.cleanliness <= 25 ? 'very dirty' : pet.cleanliness <= 50 ? 'needs washing' : pet.cleanliness <= 75 ? 'clean' : 'sparkly clean';
            const happyDesc = pet.happiness <= 25 ? 'sad' : pet.happiness <= 50 ? 'bored' : pet.happiness <= 75 ? 'happy' : 'very happy';
            const curTimeForEnergy = gameState.timeOfDay || 'day';
            const isNightForEnergy = curTimeForEnergy === 'night' || curTimeForEnergy === 'sunset';
            const energyDesc = pet.energy <= 25 ? 'exhausted' : pet.energy <= 50 ? (isNightForEnergy ? 'sleepy - bedtime!' : 'tired') : pet.energy <= 75 ? 'rested' : 'full of energy';

            document.getElementById('feed-btn').setAttribute('aria-label', `Feed your pet. Hunger level: ${pet.hunger}%, ${hungerDesc}`);
            document.getElementById('wash-btn').setAttribute('aria-label', `Wash your pet. Cleanliness: ${pet.cleanliness}%, ${cleanDesc}`);
            document.getElementById('play-btn').setAttribute('aria-label', `Play with your pet. Happiness: ${pet.happiness}%, ${happyDesc}`);
            document.getElementById('sleep-btn').setAttribute('aria-label', `Put your pet to sleep${isNightForEnergy ? ' (extra effective at night!)' : ''}. Energy: ${pet.energy}%, ${energyDesc}`);

            // Update medicine button with overall wellness description
            const avgWellness = Math.round((pet.hunger + pet.cleanliness + pet.happiness + pet.energy) / 4);
            const wellnessDesc = avgWellness <= 25 ? 'not feeling well' : avgWellness <= 50 ? 'could feel better' : avgWellness <= 75 ? 'feeling good' : 'feeling great';
            document.getElementById('medicine-btn').setAttribute('aria-label', `Give medicine to help your pet feel better. Pet is ${wellnessDesc}`);

            // Update groom button - grooming helps cleanliness and happiness
            const groomDesc = pet.cleanliness <= 50 ? 'could use some grooming' : 'looking good';
            document.getElementById('groom-btn').setAttribute('aria-label', `Groom your pet - brush fur and trim nails. Cleanliness: ${pet.cleanliness}%, ${groomDesc}`);

            // Update exercise button - exercise boosts happiness but uses energy
            const exerciseDesc = pet.energy <= 25 ? 'too tired to exercise' : pet.happiness <= 50 ? 'needs some exercise' : 'enjoying activities';
            document.getElementById('exercise-btn').setAttribute('aria-label', `Exercise your pet - take a walk or play fetch. Happiness: ${pet.happiness}%, ${exerciseDesc}`);

            // Update pet/cuddle button - petting gives affection
            const cuddleDesc = pet.happiness <= 50 ? 'wants cuddles' : 'loves your attention';
            document.getElementById('pet-btn').setAttribute('aria-label', `Pet and cuddle your pet. Happiness: ${pet.happiness}%, ${cuddleDesc}`);
        }

        function updatePetMood() {
            const pet = gameState.pet;
            const petData = PET_TYPES[pet.type];
            const mood = getMood(pet);
            const moodMessage = randomFromArray(MOOD_MESSAGES[mood]);

            // Update pet SVG
            const petContainer = document.getElementById('pet-container');
            petContainer.innerHTML = generatePetSVG(pet, mood);

            // Update mood text with weather and time-of-day notes
            const petDisplayName = pet.name || petData.name;
            const weather = gameState.weather || 'sunny';
            const weatherData = WEATHER_TYPES[weather];
            const weatherMoodNote = getWeatherMoodMessage(pet, weather);
            const timeMoodNote = getTimeMoodMessage(pet);
            const petMoodEl = document.getElementById('pet-mood');
            if (petMoodEl) {
                let noteHTML = '';
                if (weatherMoodNote) noteHTML += `<span class="weather-mood-note">${weatherData.icon} ${petDisplayName} ${weatherMoodNote}</span>`;
                if (timeMoodNote) noteHTML += `<span class="weather-mood-note">${getTimeIcon(gameState.timeOfDay)} ${petDisplayName} ${timeMoodNote}</span>`;
                petMoodEl.innerHTML = `${petDisplayName} ${moodMessage}${noteHTML}`;
            }

            // Update mood badge
            const badge = document.getElementById('mood-badge');
            if (badge) {
                const moodEmoji = { happy: 'üòä', neutral: 'üòê', sad: 'üò¢', sleepy: 'üò¥', energetic: '‚ö°' };
                const moodLabel = { happy: 'Happy', neutral: 'Okay', sad: 'Sad', sleepy: 'Sleepy', energetic: 'Energetic' };
                badge.className = `mood-badge ${mood}`;
                badge.innerHTML = `<span class="mood-badge-emoji">${moodEmoji[mood] || 'üòê'}</span><span>${moodLabel[mood] || 'Okay'}</span>`;
            }
        }

        // ==================== PARTICLE EFFECTS ====================

        function createSparkles(container, count) {
            for (let i = 0; i < count; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle-particle';
                sparkle.style.left = `${30 + Math.random() * 40}%`;
                sparkle.style.top = `${30 + Math.random() * 40}%`;
                sparkle.style.background = ['#FFD700', '#FF69B4', '#87CEEB', '#98FB98'][Math.floor(Math.random() * 4)];
                container.appendChild(sparkle);
                setTimeout(() => sparkle.remove(), 1000);
            }
        }

        function createFoodParticles(container) {
            const foods = ['üçé', 'ü•ï', 'üç™', 'ü•¨', 'üåæ'];
            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'sparkle-particle';
                particle.textContent = foods[Math.floor(Math.random() * foods.length)];
                particle.style.left = `${30 + Math.random() * 40}%`;
                particle.style.top = `${40 + Math.random() * 30}%`;
                particle.style.background = 'transparent';
                particle.style.fontSize = '1.5rem';
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1000);
            }
        }

        function createBubbles(container) {
            for (let i = 0; i < 8; i++) {
                const bubble = document.createElement('div');
                bubble.className = 'bubble-particle';
                bubble.style.left = `${20 + Math.random() * 60}%`;
                bubble.style.top = `${30 + Math.random() * 40}%`;
                bubble.style.animationDelay = `${Math.random() * 0.3}s`;
                container.appendChild(bubble);
                setTimeout(() => bubble.remove(), 1500);
            }
        }

        function createHearts(container) {
            for (let i = 0; i < 5; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart-particle';
                heart.textContent = '‚ù§Ô∏è';
                heart.style.left = `${25 + Math.random() * 50}%`;
                heart.style.top = `${35 + Math.random() * 30}%`;
                heart.style.animationDelay = `${Math.random() * 0.3}s`;
                container.appendChild(heart);
                setTimeout(() => heart.remove(), 1200);
            }
        }

        function createZzz(container) {
            // Create Zzz particles
            const zzzTexts = ['Z', 'z', 'Z'];
            for (let i = 0; i < 3; i++) {
                const zzz = document.createElement('div');
                zzz.className = 'zzz-particle';
                zzz.textContent = zzzTexts[i];
                zzz.style.left = `${45 + i * 10}%`;
                zzz.style.top = `${30 + i * 5}%`;
                zzz.style.animationDelay = `${i * 0.3}s`;
                zzz.style.fontSize = `${1.5 - i * 0.2}rem`;
                container.appendChild(zzz);
                setTimeout(() => zzz.remove(), 1800);
            }
            // Create star particles
            const stars = ['‚≠ê', '‚ú®', 'üåü'];
            for (let i = 0; i < 4; i++) {
                const star = document.createElement('div');
                star.className = 'star-particle';
                star.textContent = stars[Math.floor(Math.random() * stars.length)];
                star.style.left = `${20 + Math.random() * 60}%`;
                star.style.top = `${25 + Math.random() * 40}%`;
                star.style.animationDelay = `${Math.random() * 0.5}s`;
                container.appendChild(star);
                setTimeout(() => star.remove(), 1500);
            }
        }

        function createMedicineParticles(container) {
            // Gentle, friendly healing symbols - bandaids, hearts, sparkles, rainbows
            const healingSymbols = ['ü©π', 'üíï', '‚ú®', 'üåà', 'üíñ', '‚≠ê'];
            for (let i = 0; i < 6; i++) {
                const particle = document.createElement('div');
                particle.className = 'medicine-particle';
                particle.textContent = healingSymbols[i % healingSymbols.length];
                particle.style.left = `${20 + Math.random() * 60}%`;
                particle.style.top = `${25 + Math.random() * 40}%`;
                particle.style.animationDelay = `${i * 0.15}s`;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1600);
            }
        }

        function createGroomParticles(container) {
            // Grooming symbols - scissors, sparkles, nail care, bow, hearts
            const groomSymbols = ['‚úÇÔ∏è', '‚ú®', 'üí´', 'üíÖ', 'üéÄ', 'üíú'];
            for (let i = 0; i < 6; i++) {
                const particle = document.createElement('div');
                particle.className = 'groom-particle';
                particle.textContent = groomSymbols[i % groomSymbols.length];
                particle.style.left = `${20 + Math.random() * 60}%`;
                particle.style.top = `${25 + Math.random() * 40}%`;
                particle.style.animationDelay = `${i * 0.15}s`;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1600);
            }
        }

        function createExerciseParticles(container) {
            // Exercise symbols - running, ball, paw prints, fetch stick
            const exerciseSymbols = ['üéæ', 'ü¶¥', 'üêæ', 'üí®', '‚≠ê', 'üèÉ'];
            for (let i = 0; i < 6; i++) {
                const particle = document.createElement('div');
                particle.className = 'exercise-particle';
                particle.textContent = exerciseSymbols[i % exerciseSymbols.length];
                particle.style.left = `${15 + Math.random() * 70}%`;
                particle.style.top = `${25 + Math.random() * 40}%`;
                particle.style.animationDelay = `${i * 0.12}s`;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1600);
            }
        }

        function createTreatParticles(container, treatEmoji) {
            // Treat symbols - the chosen treat plus sparkles, stars, hearts
            const symbols = [treatEmoji, '‚ú®', '‚≠ê', 'üíñ', treatEmoji, 'üåü'];
            for (let i = 0; i < 6; i++) {
                const particle = document.createElement('div');
                particle.className = 'treat-particle';
                particle.textContent = symbols[i % symbols.length];
                particle.style.left = `${15 + Math.random() * 70}%`;
                particle.style.top = `${20 + Math.random() * 45}%`;
                particle.style.animationDelay = `${i * 0.12}s`;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1700);
            }
        }

        function createCuddleParticles(container) {
            // Cuddle symbols - hearts, sparkles, warm emojis
            const cuddleSymbols = ['üíï', 'üíó', '‚ú®', 'ü•∞', 'üíñ', 'üíõ'];
            for (let i = 0; i < 7; i++) {
                const particle = document.createElement('div');
                particle.className = 'cuddle-particle';
                particle.textContent = cuddleSymbols[i % cuddleSymbols.length];
                particle.style.left = `${15 + Math.random() * 70}%`;
                particle.style.top = `${20 + Math.random() * 45}%`;
                particle.style.animationDelay = `${i * 0.1}s`;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1700);
            }
        }

        // ==================== MINI GAMES ====================

        const MINI_GAMES = [
            { id: 'fetch', name: 'Fetch', icon: 'üéæ', description: 'Throw a ball for your pet!' },
            { id: 'hideseek', name: 'Hide & Seek', icon: 'üç™', description: 'Find hidden treats around the screen!' },
            { id: 'bubblepop', name: 'Bubble Pop', icon: 'ü´ß', description: 'Pop bubbles during bath time!' },
            { id: 'matching', name: 'Matching', icon: 'üÉè', description: 'Match food & accessory pairs!' },
            { id: 'simonsays', name: 'Simon Says', icon: 'üéµ', description: 'Follow the pattern of colors & sounds!' },
            { id: 'coloring', name: 'Coloring', icon: 'üé®', description: 'Color your pet or backgrounds!' }
        ];

        function openMiniGamesMenu() {
            // Remove any existing menu
            const existing = document.querySelector('.minigame-menu-overlay');
            if (existing) existing.remove();

            const overlay = document.createElement('div');
            overlay.className = 'minigame-menu-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-labelledby', 'minigame-menu-title');

            let cardsHTML = '';
            MINI_GAMES.forEach(game => {
                cardsHTML += `
                    <button class="minigame-card" data-game="${game.id}" aria-label="Play ${game.name} - ${game.description}">
                        <span class="minigame-card-icon" aria-hidden="true">${game.icon}</span>
                        <span class="minigame-card-name">${game.name}</span>
                    </button>
                `;
            });

            overlay.innerHTML = `
                <div class="minigame-menu">
                    <h2 class="minigame-menu-title" id="minigame-menu-title">üéÆ Mini Games</h2>
                    <p class="minigame-menu-subtitle">Pick a game to play with your pet!</p>
                    <div class="minigame-list">
                        ${cardsHTML}
                    </div>
                    <button class="minigame-close-btn" id="minigame-close">Back</button>
                </div>
            `;

            document.body.appendChild(overlay);

            // Event listeners
            overlay.querySelector('#minigame-close').addEventListener('click', () => overlay.remove());
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) overlay.remove();
            });

            // Game card listeners
            overlay.querySelectorAll('.minigame-card').forEach(card => {
                card.addEventListener('click', () => {
                    const gameId = card.getAttribute('data-game');
                    overlay.remove();
                    startMiniGame(gameId);
                });
            });

            // Escape to close
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);

            // Focus first game card
            const firstCard = overlay.querySelector('.minigame-card');
            if (firstCard) firstCard.focus();

            announce('Mini Games menu opened. Pick a game to play!');
        }

        function startMiniGame(gameId) {
            switch (gameId) {
                case 'fetch':
                    startFetchGame();
                    break;
                case 'hideseek':
                    startHideSeekGame();
                    break;
                case 'bubblepop':
                    startBubblePopGame();
                    break;
                case 'matching':
                    startMatchingGame();
                    break;
                case 'simonsays':
                    startSimonSaysGame();
                    break;
                case 'coloring':
                    startColoringGame();
                    break;
            }
        }

        // ==================== FETCH MINI-GAME ====================

        let fetchState = null;

        function startFetchGame() {
            fetchState = {
                score: 0,
                phase: 'ready', // 'ready', 'thrown', 'fetching', 'returning'
                ballX: 50,
                ballY: 160,
                petX: 45,
                targetX: 0,
                _timeouts: []
            };

            renderFetchGame();
            announce('Fetch game started! Tap the field to throw the ball!');
        }

        function renderFetchGame() {
            // Remove any existing game
            const existing = document.querySelector('.fetch-game-overlay');
            if (existing) existing.remove();

            const pet = gameState.pet;
            const petData = PET_TYPES[pet.type];
            const mood = getMood(pet);

            const overlay = document.createElement('div');
            overlay.className = 'fetch-game-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', 'Fetch mini game');

            overlay.innerHTML = `
                <div class="fetch-game">
                    <h2 class="fetch-game-title">üéæ Fetch!</h2>
                    <p class="fetch-game-score" id="fetch-score">Fetched: ${fetchState.score}</p>
                    <div class="fetch-field" id="fetch-field" role="button" aria-label="Tap to throw the ball" tabindex="0">
                        <div class="fetch-field-clouds">‚òÅÔ∏è ‚òÅÔ∏è</div>
                        <div class="fetch-field-flowers">üå∏ üåº üå∑ üåª</div>
                        <div class="fetch-ball" id="fetch-ball" style="left: ${fetchState.ballX}%; top: ${fetchState.ballY}px;">üéæ</div>
                        <div class="fetch-ball-shadow" id="fetch-ball-shadow" style="left: ${fetchState.ballX}%; top: 185px;"></div>
                        <div class="fetch-pet" id="fetch-pet" style="left: ${fetchState.petX}%;">
                            ${generatePetSVG(pet, mood)}
                        </div>
                    </div>
                    <p class="fetch-instruction" id="fetch-instruction">Tap the field to throw the ball!</p>
                    <div class="fetch-buttons">
                        <button class="fetch-throw-btn" id="fetch-throw-btn">üéæ Throw!</button>
                        <button class="fetch-done-btn" id="fetch-done-btn">Done</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Event listeners
            const field = overlay.querySelector('#fetch-field');
            const throwBtn = overlay.querySelector('#fetch-throw-btn');
            const doneBtn = overlay.querySelector('#fetch-done-btn');

            field.addEventListener('click', (e) => handleFetchThrow(e));
            field.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleFetchThrow(e);
                }
            });

            throwBtn.addEventListener('click', (e) => handleFetchThrow(e));

            doneBtn.addEventListener('click', () => endFetchGame());

            // Escape to exit
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    endFetchGame();
                }
            }
            document.addEventListener('keydown', handleEscape);
            fetchState._handleEscape = handleEscape;

            throwBtn.focus();
        }

        function handleFetchThrow(e) {
            if (!fetchState || fetchState.phase !== 'ready') return;

            fetchState.phase = 'thrown';

            const field = document.getElementById('fetch-field');
            const ball = document.getElementById('fetch-ball');
            const shadow = document.getElementById('fetch-ball-shadow');
            const pet = document.getElementById('fetch-pet');
            const instruction = document.getElementById('fetch-instruction');
            const throwBtn = document.getElementById('fetch-throw-btn');

            if (throwBtn) throwBtn.disabled = true;

            // Calculate where the ball lands (random position on the right side)
            const targetX = 60 + Math.random() * 25;
            fetchState.targetX = targetX;

            // Animate ball flying to the right with an arc
            instruction.textContent = 'Nice throw!';
            instruction.className = 'fetch-instruction highlight';

            // Ball arc animation - first goes up, then lands
            ball.style.transition = 'none';
            ball.offsetHeight; // force reflow

            // Phase 1: Ball arcs up and to the right
            ball.classList.add('arc');
            ball.style.left = targetX + '%';
            ball.style.top = '60px';

            if (shadow) {
                shadow.style.transition = 'left 0.8s ease-out, opacity 0.3s';
                shadow.style.left = targetX + '%';
                shadow.style.opacity = '0.05';
            }

            // Phase 2: Ball drops down to ground
            fetchState._timeouts.push(setTimeout(() => {
                if (!fetchState) return;
                ball.style.transition = 'top 0.35s cubic-bezier(0.55, 0, 1, 0.45)';
                ball.style.top = '155px';
                if (shadow) {
                    shadow.style.opacity = '0.15';
                }
            }, 700));

            // Phase 3: Pet runs to fetch the ball
            fetchState._timeouts.push(setTimeout(() => {
                if (!fetchState) return;
                fetchState.phase = 'fetching';
                instruction.textContent = `${PET_TYPES[gameState.pet.type].emoji} Running to get it!`;

                pet.classList.add('running');
                pet.style.left = (targetX - 5) + '%';
            }, 1100));

            // Phase 4: Pet reaches ball
            fetchState._timeouts.push(setTimeout(() => {
                if (!fetchState) return;
                // Hide the ball (pet picked it up)
                ball.style.opacity = '0';
                ball.style.transition = 'opacity 0.15s';

                instruction.textContent = `${PET_TYPES[gameState.pet.type].emoji} Got it!`;
                instruction.className = 'fetch-instruction highlight';

                // Show a reward particle
                showFetchReward(field, targetX);
            }, 2000));

            // Phase 5: Pet returns to start
            fetchState._timeouts.push(setTimeout(() => {
                if (!fetchState) return;
                fetchState.phase = 'returning';
                instruction.textContent = `${PET_TYPES[gameState.pet.type].emoji} Bringing it back!`;
                instruction.className = 'fetch-instruction';

                pet.classList.remove('running');
                pet.classList.add('returning');
                pet.style.left = '45%';
            }, 2400));

            // Phase 6: Complete - pet is back, ready for another throw
            fetchState._timeouts.push(setTimeout(() => {
                if (!fetchState) return;
                fetchState.score++;
                fetchState.phase = 'ready';

                // Update score display
                const scoreEl = document.getElementById('fetch-score');
                if (scoreEl) scoreEl.textContent = `Fetched: ${fetchState.score}`;

                // Reset ball position
                ball.style.transition = 'none';
                ball.style.left = '50%';
                ball.style.top = '160px';
                ball.style.opacity = '1';

                if (shadow) {
                    shadow.style.transition = 'none';
                    shadow.style.left = '50%';
                    shadow.style.opacity = '0.15';
                }

                pet.classList.remove('returning');
                pet.style.transition = 'none';
                pet.style.left = '45%';

                instruction.textContent = 'Throw again! Tap the field!';
                instruction.className = 'fetch-instruction highlight';

                if (throwBtn) throwBtn.disabled = false;

                announce(`Great fetch! Score: ${fetchState.score}. Throw again!`);
            }, 3400));
        }

        function showFetchReward(container, xPercent) {
            const reward = document.createElement('div');
            reward.className = 'fetch-reward';
            reward.textContent = '+1 üéæ';
            reward.style.left = xPercent + '%';
            reward.style.top = '120px';
            container.appendChild(reward);
            setTimeout(() => reward.remove(), 1000);
        }

        function endFetchGame() {
            if (fetchState && fetchState._handleEscape) {
                document.removeEventListener('keydown', fetchState._handleEscape);
            }
            if (fetchState && fetchState._timeouts) {
                fetchState._timeouts.forEach(id => clearTimeout(id));
            }

            const overlay = document.querySelector('.fetch-game-overlay');
            if (overlay) overlay.remove();

            // Apply rewards based on score
            if (fetchState && fetchState.score > 0 && gameState.pet) {
                const bonus = Math.min(fetchState.score * 5, 30);
                gameState.pet.happiness = clamp(gameState.pet.happiness + bonus, 0, 100);
                gameState.pet.energy = clamp(gameState.pet.energy - Math.min(fetchState.score * 2, 10), 0, 100);
                gameState.pet.hunger = clamp(gameState.pet.hunger - Math.min(fetchState.score, 5), 0, 100);

                // Show feedback on main screen
                const petData = PET_TYPES[gameState.pet.type];
                const feedback = document.getElementById('feedback');
                if (feedback) {
                    feedback.textContent = `${petData.emoji} Loved playing fetch! (${fetchState.score} catches)`;
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 3000);
                }

                // Update displays
                updateNeedDisplays();
                updatePetMood();
                saveGame();

                announce(`Fetch game over! ${fetchState.score} catches! Happiness +${bonus}!`);
            }

            fetchState = null;
        }

        // ==================== HIDE & SEEK MINI-GAME ====================

        let hideSeekState = null;

        const HIDESEEK_OBJECTS = [
            { emoji: 'üå≥', name: 'tree' },
            { emoji: 'ü™®', name: 'rock' },
            { emoji: 'üåª', name: 'sunflower' },
            { emoji: 'üçÑ', name: 'mushroom' },
            { emoji: 'ü™µ', name: 'log' },
            { emoji: 'üåø', name: 'bush' },
            { emoji: 'üè†', name: 'house' },
            { emoji: 'üì¶', name: 'box' },
            { emoji: 'ü™£', name: 'bucket' },
            { emoji: 'üß∫', name: 'basket' },
            { emoji: 'üé™', name: 'tent' },
            { emoji: 'ü™¥', name: 'plant' }
        ];

        const HIDESEEK_TREATS = ['üç™', 'ü¶¥', 'üßÄ', 'ü•ï', 'üçé', 'üêü'];

        function startHideSeekGame() {
            const totalTreats = 5;
            const spotCount = 8;

            // Pick random hiding spots from available objects
            const shuffled = [...HIDESEEK_OBJECTS].sort(() => Math.random() - 0.5);
            const spots = shuffled.slice(0, spotCount);

            // Assign positions that don't overlap
            const positions = generateHideSeekPositions(spotCount);

            // Pick which spots have treats hidden under them
            const treatIndices = [];
            const indexPool = Array.from({ length: spotCount }, (_, i) => i);
            indexPool.sort(() => Math.random() - 0.5);
            for (let i = 0; i < totalTreats; i++) {
                treatIndices.push(indexPool[i]);
            }

            // Pick a random treat emoji for this round
            const treatEmoji = HIDESEEK_TREATS[Math.floor(Math.random() * HIDESEEK_TREATS.length)];

            hideSeekState = {
                score: 0,
                totalTreats: totalTreats,
                treatsFound: 0,
                spots: spots.map((obj, i) => ({
                    ...obj,
                    x: positions[i].x,
                    y: positions[i].y,
                    hasTreat: treatIndices.includes(i),
                    searched: false
                })),
                treatEmoji: treatEmoji,
                timeLeft: 30,
                timerId: null,
                phase: 'playing' // 'playing', 'finished'
            };

            renderHideSeekGame();
            startHideSeekTimer();
            announce(`Hide and Seek started! Find ${totalTreats} hidden treats! Tap the objects to search under them.`);
        }

        function generateHideSeekPositions(count) {
            const positions = [];
            const minDist = 18;

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let pos;
                do {
                    pos = {
                        x: 8 + Math.random() * 72,
                        y: 5 + Math.random() * 65
                    };
                    attempts++;
                } while (
                    attempts < 50 &&
                    positions.some(p => Math.hypot(p.x - pos.x, p.y - pos.y) < minDist)
                );
                positions.push(pos);
            }
            return positions;
        }

        function renderHideSeekGame() {
            const existing = document.querySelector('.hideseek-game-overlay');
            if (existing) existing.remove();

            const pet = gameState.pet;
            const petData = PET_TYPES[pet.type];
            const mood = getMood(pet);

            const overlay = document.createElement('div');
            overlay.className = 'hideseek-game-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', 'Hide and Seek mini game');

            let spotsHTML = '';
            hideSeekState.spots.forEach((spot, i) => {
                spotsHTML += `<div class="hideseek-hiding-spot" data-index="${i}"
                    style="left: ${spot.x}%; top: ${spot.y}%;"
                    role="button" tabindex="0"
                    aria-label="Search under the ${spot.name}">${spot.emoji}</div>`;
            });

            let progressDots = '';
            for (let i = 0; i < hideSeekState.totalTreats; i++) {
                progressDots += `<div class="hideseek-progress-dot" id="hideseek-dot-${i}"></div>`;
            }

            overlay.innerHTML = `
                <div class="hideseek-game">
                    <h2 class="hideseek-game-title">${hideSeekState.treatEmoji} Hide & Seek!</h2>
                    <p class="hideseek-game-score" id="hideseek-score">Found: ${hideSeekState.treatsFound} / ${hideSeekState.totalTreats}</p>
                    <div class="hideseek-progress" id="hideseek-progress">${progressDots}</div>
                    <p class="hideseek-game-timer" id="hideseek-timer">Time: ${hideSeekState.timeLeft}s</p>
                    <div class="hideseek-field" id="hideseek-field">
                        ${spotsHTML}
                        <div class="hideseek-pet" id="hideseek-pet">
                            ${generatePetSVG(pet, mood)}
                        </div>
                    </div>
                    <p class="hideseek-instruction" id="hideseek-instruction">Tap objects to find the hidden treats!</p>
                    <div class="hideseek-buttons">
                        <button class="hideseek-done-btn" id="hideseek-done-btn">Done</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Event listeners for each hiding spot
            overlay.querySelectorAll('.hideseek-hiding-spot').forEach(el => {
                el.addEventListener('click', () => handleHideSeekTap(parseInt(el.dataset.index)));
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleHideSeekTap(parseInt(el.dataset.index));
                    }
                });
            });

            const doneBtn = overlay.querySelector('#hideseek-done-btn');
            doneBtn.addEventListener('click', () => endHideSeekGame());

            // Escape to exit
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    endHideSeekGame();
                }
            }
            document.addEventListener('keydown', handleEscape);
            hideSeekState._handleEscape = handleEscape;

            // Focus the first hiding spot
            const firstSpot = overlay.querySelector('.hideseek-hiding-spot');
            if (firstSpot) firstSpot.focus();
        }

        function startHideSeekTimer() {
            if (hideSeekState.timerId) clearInterval(hideSeekState.timerId);

            hideSeekState.timerId = setInterval(() => {
                if (!hideSeekState || hideSeekState.phase !== 'playing') return;

                hideSeekState.timeLeft--;
                const timerEl = document.getElementById('hideseek-timer');
                if (timerEl) timerEl.textContent = `Time: ${hideSeekState.timeLeft}s`;

                if (hideSeekState.timeLeft <= 5 && timerEl) {
                    timerEl.style.color = '#F44336';
                    timerEl.style.fontWeight = 'bold';
                }

                if (hideSeekState.timeLeft <= 0) {
                    hideSeekState.phase = 'finished';
                    clearInterval(hideSeekState.timerId);
                    finishHideSeekRound();
                }
            }, 1000);
        }

        function handleHideSeekTap(index) {
            if (!hideSeekState || hideSeekState.phase !== 'playing') return;

            const spot = hideSeekState.spots[index];
            if (spot.searched) return;

            spot.searched = true;

            const spotEl = document.querySelectorAll('.hideseek-hiding-spot')[index];
            const field = document.getElementById('hideseek-field');
            const instruction = document.getElementById('hideseek-instruction');
            const petEl = document.getElementById('hideseek-pet');

            // Move pet toward the tapped spot
            if (petEl) {
                petEl.style.left = spot.x + '%';
                petEl.style.bottom = (80 - spot.y) + '%';
            }

            if (spot.hasTreat) {
                // Found a treat!
                hideSeekState.treatsFound++;
                hideSeekState.score++;

                spotEl.classList.add('found');

                // Show treat emoji popping up
                const treat = document.createElement('div');
                treat.className = 'hideseek-treat';
                treat.textContent = hideSeekState.treatEmoji;
                treat.style.left = spot.x + '%';
                treat.style.top = spot.y + '%';
                field.appendChild(treat);

                // Collect animation
                setTimeout(() => treat.classList.add('collected'), 400);
                setTimeout(() => treat.remove(), 1000);

                // Show reward float
                const reward = document.createElement('div');
                reward.className = 'hideseek-reward';
                reward.textContent = `+1 ${hideSeekState.treatEmoji}`;
                reward.style.left = spot.x + '%';
                reward.style.top = (spot.y - 5) + '%';
                field.appendChild(reward);
                setTimeout(() => reward.remove(), 1000);

                // Update score
                const scoreEl = document.getElementById('hideseek-score');
                if (scoreEl) scoreEl.textContent = `Found: ${hideSeekState.treatsFound} / ${hideSeekState.totalTreats}`;

                // Update progress dots
                const dot = document.getElementById(`hideseek-dot-${hideSeekState.treatsFound - 1}`);
                if (dot) dot.classList.add('found');

                // Pet celebrates
                if (petEl) {
                    petEl.classList.add('celebrating');
                    setTimeout(() => petEl.classList.remove('celebrating'), 500);
                }

                instruction.textContent = `Found a treat! ${hideSeekState.treatEmoji}`;
                instruction.className = 'hideseek-instruction highlight';

                announce(`Found a treat! ${hideSeekState.treatsFound} of ${hideSeekState.totalTreats} found.`);

                // Mark spot as searched visually after animation
                setTimeout(() => spotEl.classList.add('searched'), 600);

                // Check if all treats found
                if (hideSeekState.treatsFound >= hideSeekState.totalTreats) {
                    hideSeekState.phase = 'finished';
                    clearInterval(hideSeekState.timerId);
                    setTimeout(() => finishHideSeekRound(), 800);
                }
            } else {
                // No treat here
                spotEl.classList.add('searched');

                const miss = document.createElement('div');
                miss.className = 'hideseek-miss';
                miss.textContent = '‚ùå';
                miss.style.left = spot.x + '%';
                miss.style.top = spot.y + '%';
                field.appendChild(miss);
                setTimeout(() => miss.remove(), 700);

                instruction.textContent = 'Nothing here... keep looking!';
                instruction.className = 'hideseek-instruction';

                announce('Nothing under this one. Keep searching!');
            }
        }

        function finishHideSeekRound() {
            const instruction = document.getElementById('hideseek-instruction');
            const allFound = hideSeekState.treatsFound >= hideSeekState.totalTreats;

            if (allFound) {
                if (instruction) {
                    instruction.textContent = `Amazing! Found all ${hideSeekState.totalTreats} treats! ${hideSeekState.treatEmoji}`;
                    instruction.className = 'hideseek-instruction highlight';
                }
                announce(`Fantastic! All ${hideSeekState.totalTreats} treats found!`);
            } else {
                if (instruction) {
                    instruction.textContent = `Time's up! Found ${hideSeekState.treatsFound} of ${hideSeekState.totalTreats} treats.`;
                    instruction.className = 'hideseek-instruction';
                }
                announce(`Time is up! Found ${hideSeekState.treatsFound} of ${hideSeekState.totalTreats} treats.`);
            }

            // Reveal unfound treats
            hideSeekState.spots.forEach((spot, i) => {
                if (spot.hasTreat && !spot.searched) {
                    const spotEl = document.querySelectorAll('.hideseek-hiding-spot')[i];
                    if (spotEl) {
                        spotEl.classList.add('searched');
                        const field = document.getElementById('hideseek-field');
                        const reveal = document.createElement('div');
                        reveal.className = 'hideseek-treat';
                        reveal.textContent = hideSeekState.treatEmoji;
                        reveal.style.left = spot.x + '%';
                        reveal.style.top = spot.y + '%';
                        reveal.style.opacity = '0.5';
                        field.appendChild(reveal);
                    }
                }
            });

            // Disable all spots
            document.querySelectorAll('.hideseek-hiding-spot').forEach(el => {
                el.style.pointerEvents = 'none';
            });
        }

        function endHideSeekGame() {
            if (hideSeekState && hideSeekState._handleEscape) {
                document.removeEventListener('keydown', hideSeekState._handleEscape);
            }

            if (hideSeekState && hideSeekState.timerId) {
                clearInterval(hideSeekState.timerId);
            }

            const overlay = document.querySelector('.hideseek-game-overlay');
            if (overlay) overlay.remove();

            // Apply rewards based on treats found
            if (hideSeekState && hideSeekState.treatsFound > 0 && gameState.pet) {
                const bonus = Math.min(hideSeekState.treatsFound * 6, 30);
                gameState.pet.happiness = clamp(gameState.pet.happiness + bonus, 0, 100);
                gameState.pet.energy = clamp(gameState.pet.energy - Math.min(hideSeekState.treatsFound * 2, 8), 0, 100);
                gameState.pet.hunger = clamp(gameState.pet.hunger + Math.min(hideSeekState.treatsFound * 2, 10), 0, 100);

                const petData = PET_TYPES[gameState.pet.type];
                const feedback = document.getElementById('feedback');
                if (feedback) {
                    feedback.textContent = `${petData.emoji} Loved finding treats! (${hideSeekState.treatsFound} found)`;
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 3000);
                }

                updateNeedDisplays();
                updatePetMood();
                saveGame();

                announce(`Hide and Seek over! ${hideSeekState.treatsFound} treats found! Happiness +${bonus}!`);
            }

            hideSeekState = null;
        }

        // ==================== BUBBLE POP MINI-GAME ====================

        let bubblePopState = null;

        const BUBBLE_SIZES = [
            { size: 55, points: 1 },
            { size: 45, points: 2 },
            { size: 35, points: 3 }
        ];

        const BUBBLE_SPLASH_EMOJIS = ['üíß', '‚ú®', 'üí¶', 'ü´ß', 'üßº'];

        function startBubblePopGame() {
            if (!gameState.pet) return;

            const existing = document.querySelector('.bubblepop-game-overlay');
            if (existing) existing.remove();

            bubblePopState = {
                score: 0,
                timeLeft: 30,
                bubbles: [],
                bubbleIdCounter: 0,
                spawnInterval: null,
                timerInterval: null,
                floatIntervals: [],
                active: true
            };

            renderBubblePopGame();
            startBubblePopTimer();
            startBubbleSpawner();

            announce('Bubble Pop! Tap the bubbles to pop them! 30 seconds!');
        }

        function renderBubblePopGame() {
            const overlay = document.createElement('div');
            overlay.className = 'bubblepop-game-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', 'Bubble Pop mini-game');

            const pet = gameState.pet;
            const mood = getMood(pet);
            const petSVG = generatePetSVG(pet, mood);

            overlay.innerHTML = `
                <div class="bubblepop-game">
                    <h2 class="bubblepop-game-title">ü´ß Bubble Pop!</h2>
                    <p class="bubblepop-game-score" id="bubblepop-score" aria-live="polite">Bubbles popped: 0</p>
                    <p class="bubblepop-game-timer" id="bubblepop-timer">‚è±Ô∏è 30s</p>
                    <div class="bubblepop-field" id="bubblepop-field" aria-label="Bath area - tap bubbles to pop them">
                        <div class="bubblepop-suds"></div>
                        <div class="bubblepop-pet" id="bubblepop-pet">${petSVG}</div>
                    </div>
                    <p class="bubblepop-instruction" id="bubblepop-instruction">Tap the bubbles to pop them!</p>
                    <div class="bubblepop-buttons">
                        <button class="bubblepop-done-btn" id="bubblepop-done" aria-label="Stop playing Bubble Pop">Done</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Done button
            overlay.querySelector('#bubblepop-done').addEventListener('click', () => endBubblePopGame());

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) endBubblePopGame();
            });

            // Escape to close
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    endBubblePopGame();
                }
            }
            document.addEventListener('keydown', handleEscape);
            bubblePopState._handleEscape = handleEscape;

            // Focus done button
            overlay.querySelector('#bubblepop-done').focus();

            // Spawn initial batch of bubbles
            for (let i = 0; i < 5; i++) {
                setTimeout(() => spawnBubble(), i * 200);
            }
        }

        function startBubblePopTimer() {
            if (!bubblePopState) return;

            bubblePopState.timerInterval = setInterval(() => {
                if (!bubblePopState || !bubblePopState.active) return;

                bubblePopState.timeLeft--;
                const timerEl = document.getElementById('bubblepop-timer');
                if (timerEl) {
                    timerEl.textContent = `‚è±Ô∏è ${bubblePopState.timeLeft}s`;
                    if (bubblePopState.timeLeft <= 5) {
                        timerEl.style.color = '#EF5350';
                        timerEl.style.fontWeight = 'bold';
                    }
                }

                if (bubblePopState.timeLeft <= 0) {
                    bubblePopState.active = false;
                    finishBubblePopRound();
                }
            }, 1000);
        }

        function startBubbleSpawner() {
            if (!bubblePopState) return;

            bubblePopState.spawnInterval = setInterval(() => {
                if (!bubblePopState || !bubblePopState.active) return;

                const field = document.getElementById('bubblepop-field');
                if (!field) return;

                // Keep between 4-8 bubbles on screen
                const currentBubbles = field.querySelectorAll('.bubblepop-bubble:not(.popping)');
                if (currentBubbles.length < 8) {
                    spawnBubble();
                }
            }, 800);
        }

        function spawnBubble() {
            if (!bubblePopState || !bubblePopState.active) return;

            const field = document.getElementById('bubblepop-field');
            if (!field) return;

            const sizeData = BUBBLE_SIZES[Math.floor(Math.random() * BUBBLE_SIZES.length)];
            const bubbleSize = sizeData.size;
            const fieldRect = field.getBoundingClientRect();
            const fieldW = field.offsetWidth;
            const fieldH = field.offsetHeight;

            // Random position, keep within bounds and above the pet
            const x = Math.random() * (fieldW - bubbleSize - 10) + 5;
            const y = Math.random() * (fieldH - bubbleSize - 80) + 5;

            const bubbleId = bubblePopState.bubbleIdCounter++;

            const bubble = document.createElement('div');
            bubble.className = 'bubblepop-bubble';
            bubble.setAttribute('role', 'button');
            bubble.setAttribute('aria-label', `Bubble - tap to pop`);
            bubble.setAttribute('tabindex', '0');
            bubble.dataset.bubbleId = bubbleId;
            bubble.dataset.points = sizeData.points;

            bubble.style.width = `${bubbleSize}px`;
            bubble.style.height = `${bubbleSize}px`;
            bubble.style.left = `${x}px`;
            bubble.style.top = `${y}px`;
            bubble.style.opacity = '0';
            bubble.style.transform = 'scale(0)';

            field.appendChild(bubble);

            // Animate in
            requestAnimationFrame(() => {
                bubble.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                bubble.style.opacity = '1';
                bubble.style.transform = 'scale(1)';
            });

            // Gentle floating animation with random offset
            const floatDuration = 2 + Math.random() * 2;
            const floatDelay = Math.random() * 2;
            bubble.style.animation = `bubbleFloat ${floatDuration}s ease-in-out ${floatDelay}s infinite`;

            // Pop on click/tap
            bubble.addEventListener('click', (e) => {
                e.stopPropagation();
                popBubble(bubble);
            });

            // Pop on keyboard
            bubble.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    popBubble(bubble);
                }
            });

            // Auto-remove bubble after a while if not popped
            setTimeout(() => {
                if (bubble.parentNode && !bubble.classList.contains('popping')) {
                    bubble.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                    bubble.style.opacity = '0';
                    bubble.style.transform = 'scale(0.5)';
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                    }, 500);
                }
            }, 4000 + Math.random() * 3000);
        }

        function popBubble(bubble) {
            if (!bubblePopState || !bubblePopState.active) return;
            if (bubble.classList.contains('popping')) return;

            bubble.classList.add('popping');
            const points = parseInt(bubble.dataset.points) || 1;

            bubblePopState.score += points;

            // Update score display
            const scoreEl = document.getElementById('bubblepop-score');
            if (scoreEl) {
                scoreEl.textContent = `Bubbles popped: ${bubblePopState.score}`;
            }

            // Show splash effect
            const field = document.getElementById('bubblepop-field');
            if (field) {
                const splash = document.createElement('div');
                splash.className = 'bubblepop-splash';
                splash.textContent = randomFromArray(BUBBLE_SPLASH_EMOJIS);
                splash.style.left = bubble.style.left;
                splash.style.top = bubble.style.top;
                field.appendChild(splash);
                setTimeout(() => splash.remove(), 600);

                // Show point reward
                const reward = document.createElement('div');
                reward.className = 'bubblepop-reward';
                reward.textContent = `+${points}`;
                reward.style.left = `${parseInt(bubble.style.left) + 10}px`;
                reward.style.top = `${parseInt(bubble.style.top) - 5}px`;
                field.appendChild(reward);
                setTimeout(() => reward.remove(), 1000);
            }

            // Make pet react on milestones
            if (bubblePopState.score % 5 === 0) {
                const petEl = document.getElementById('bubblepop-pet');
                if (petEl) {
                    petEl.classList.add('splashing');
                    setTimeout(() => petEl.classList.remove('splashing'), 400);
                }

                const instruction = document.getElementById('bubblepop-instruction');
                if (instruction) {
                    const messages = ['Splashy!', 'So bubbly!', 'Pop pop pop!', 'Bath time fun!', 'Squeaky clean!', 'Bubble master!'];
                    instruction.textContent = randomFromArray(messages);
                    instruction.classList.add('highlight');
                    setTimeout(() => instruction.classList.remove('highlight'), 500);
                }
            }

            // Remove bubble after pop animation
            setTimeout(() => {
                if (bubble.parentNode) bubble.remove();
            }, 350);
        }

        function finishBubblePopRound() {
            if (!bubblePopState) return;

            // Stop spawning
            if (bubblePopState.spawnInterval) clearInterval(bubblePopState.spawnInterval);

            // Pop all remaining bubbles for a satisfying finale
            const field = document.getElementById('bubblepop-field');
            if (field) {
                const remaining = field.querySelectorAll('.bubblepop-bubble:not(.popping)');
                remaining.forEach((bubble, i) => {
                    setTimeout(() => {
                        bubble.classList.add('popping');
                        const splash = document.createElement('div');
                        splash.className = 'bubblepop-splash';
                        splash.textContent = 'üíß';
                        splash.style.left = bubble.style.left;
                        splash.style.top = bubble.style.top;
                        field.appendChild(splash);
                        setTimeout(() => splash.remove(), 600);
                        setTimeout(() => { if (bubble.parentNode) bubble.remove(); }, 350);
                    }, i * 100);
                });
            }

            // Update instruction
            const instruction = document.getElementById('bubblepop-instruction');
            if (instruction) {
                instruction.textContent = `üõÅ Bath time over! ${bubblePopState.score} bubbles popped!`;
                instruction.classList.add('highlight');
            }

            // Auto-end after showing results
            setTimeout(() => endBubblePopGame(), 2500);
        }

        function endBubblePopGame() {
            if (bubblePopState && bubblePopState.timerInterval) clearInterval(bubblePopState.timerInterval);
            if (bubblePopState && bubblePopState.spawnInterval) clearInterval(bubblePopState.spawnInterval);

            if (bubblePopState && bubblePopState._handleEscape) {
                document.removeEventListener('keydown', bubblePopState._handleEscape);
            }

            const overlay = document.querySelector('.bubblepop-game-overlay');
            if (overlay) overlay.remove();

            // Apply rewards: bath-themed game boosts cleanliness and happiness
            if (bubblePopState && bubblePopState.score > 0 && gameState.pet) {
                const happinessBonus = Math.min(bubblePopState.score, 30);
                const cleanlinessBonus = Math.min(Math.floor(bubblePopState.score * 1.5), 30);

                gameState.pet.happiness = clamp(gameState.pet.happiness + happinessBonus, 0, 100);
                gameState.pet.cleanliness = clamp(gameState.pet.cleanliness + cleanlinessBonus, 0, 100);
                gameState.pet.energy = clamp(gameState.pet.energy - Math.min(bubblePopState.score, 10), 0, 100);

                const petData = PET_TYPES[gameState.pet.type];
                const feedback = document.getElementById('feedback');
                if (feedback) {
                    feedback.textContent = `${petData.emoji} Loved bath time! (${bubblePopState.score} bubbles popped)`;
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 3000);
                }

                updateNeedDisplays();
                updatePetMood();
                saveGame();

                announce(`Bubble Pop over! ${bubblePopState.score} bubbles popped! Happiness +${happinessBonus}! Cleanliness +${cleanlinessBonus}!`);
            }

            bubblePopState = null;
        }

        // ==================== MATCHING MINI-GAME ====================

        const MATCHING_ITEMS = [
            { emoji: 'üçé', name: 'Apple' },
            { emoji: 'ü•ï', name: 'Carrot' },
            { emoji: 'üçå', name: 'Banana' },
            { emoji: 'üßÄ', name: 'Cheese' },
            { emoji: 'ü¶¥', name: 'Bone' },
            { emoji: 'üêü', name: 'Fish' },
            { emoji: 'üéÄ', name: 'Bow' },
            { emoji: 'üß∏', name: 'Teddy' },
            { emoji: '‚≠ê', name: 'Star' },
            { emoji: 'üéæ', name: 'Ball' },
            { emoji: 'üå∏', name: 'Flower' },
            { emoji: 'üçñ', name: 'Meat' }
        ];

        let matchingState = null;

        function startMatchingGame() {
            if (!gameState.pet) return;

            const existing = document.querySelector('.matching-game-overlay');
            if (existing) existing.remove();

            // Pick 6 random items to make 12 cards (6 pairs)
            const shuffledItems = [...MATCHING_ITEMS].sort(() => Math.random() - 0.5);
            const selected = shuffledItems.slice(0, 6);
            const cards = [...selected, ...selected]
                .sort(() => Math.random() - 0.5)
                .map((item, index) => ({
                    id: index,
                    emoji: item.emoji,
                    name: item.name,
                    flipped: false,
                    matched: false
                }));

            matchingState = {
                cards: cards,
                flippedCards: [],
                matchesFound: 0,
                totalPairs: 6,
                moves: 0,
                locked: false,
                _timeouts: []
            };

            renderMatchingGame();
            announce('Matching game started! Flip cards to find matching pairs!');
        }

        function renderMatchingGame() {
            const overlay = document.createElement('div');
            overlay.className = 'matching-game-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', 'Matching mini-game');

            let cardsHTML = '';
            matchingState.cards.forEach((card, i) => {
                cardsHTML += `
                    <button class="matching-card" data-index="${i}" aria-label="Card ${i + 1} - tap to flip">
                        <div class="matching-card-inner">
                            <div class="matching-card-front">‚ùì</div>
                            <div class="matching-card-back">${card.emoji}</div>
                        </div>
                    </button>
                `;
            });

            overlay.innerHTML = `
                <div class="matching-game">
                    <h2 class="matching-game-title">üÉè Matching Game!</h2>
                    <p class="matching-game-score" id="matching-score" aria-live="polite">Pairs found: 0 / 6</p>
                    <p class="matching-game-moves" id="matching-moves">Moves: 0</p>
                    <div class="matching-grid" id="matching-grid">
                        ${cardsHTML}
                    </div>
                    <p class="matching-instruction" id="matching-instruction">Flip two cards to find a match!</p>
                    <div class="matching-buttons">
                        <button class="matching-done-btn" id="matching-done" aria-label="Stop playing Matching Game">Done</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Card click listeners
            overlay.querySelectorAll('.matching-card').forEach(card => {
                card.addEventListener('click', () => {
                    const index = parseInt(card.getAttribute('data-index'));
                    flipMatchingCard(index);
                });
            });

            // Done button
            overlay.querySelector('#matching-done').addEventListener('click', () => endMatchingGame());

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) endMatchingGame();
            });

            // Escape to close
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    endMatchingGame();
                }
            }
            document.addEventListener('keydown', handleEscape);
            matchingState._handleEscape = handleEscape;

            // Focus first card
            const firstCard = overlay.querySelector('.matching-card');
            if (firstCard) firstCard.focus();
        }

        function flipMatchingCard(index) {
            if (!matchingState || matchingState.locked) return;

            const card = matchingState.cards[index];
            if (card.flipped || card.matched) return;

            // Flip the card
            card.flipped = true;
            matchingState.flippedCards.push(index);

            const cardEl = document.querySelector(`.matching-card[data-index="${index}"]`);
            if (cardEl) cardEl.classList.add('flipped');

            // Check if two cards are flipped
            if (matchingState.flippedCards.length === 2) {
                matchingState.moves++;
                matchingState.locked = true;

                const movesEl = document.getElementById('matching-moves');
                if (movesEl) movesEl.textContent = `Moves: ${matchingState.moves}`;

                const [first, second] = matchingState.flippedCards;
                const card1 = matchingState.cards[first];
                const card2 = matchingState.cards[second];

                if (card1.emoji === card2.emoji) {
                    // Match found!
                    card1.matched = true;
                    card2.matched = true;
                    matchingState.matchesFound++;

                    const scoreEl = document.getElementById('matching-score');
                    if (scoreEl) scoreEl.textContent = `Pairs found: ${matchingState.matchesFound} / ${matchingState.totalPairs}`;

                    // Mark cards as matched visually
                    const el1 = document.querySelector(`.matching-card[data-index="${first}"]`);
                    const el2 = document.querySelector(`.matching-card[data-index="${second}"]`);
                    if (el1) el1.classList.add('matched');
                    if (el2) el2.classList.add('matched');

                    // Show encouraging message
                    const instruction = document.getElementById('matching-instruction');
                    if (instruction) {
                        const messages = ['Great match!', 'You found one!', 'Awesome!', 'Well done!', 'Nice pair!', 'Super!'];
                        instruction.textContent = randomFromArray(messages);
                        instruction.classList.add('highlight');
                        setTimeout(() => instruction.classList.remove('highlight'), 500);
                    }

                    matchingState.flippedCards = [];
                    matchingState.locked = false;

                    // Check if game is complete
                    if (matchingState.matchesFound === matchingState.totalPairs) {
                        matchingState._timeouts.push(setTimeout(() => finishMatchingGame(), 600));
                    }
                } else {
                    // No match - flip back after a delay
                    matchingState._timeouts.push(setTimeout(() => {
                        if (!matchingState) return;
                        card1.flipped = false;
                        card2.flipped = false;

                        const el1 = document.querySelector(`.matching-card[data-index="${first}"]`);
                        const el2 = document.querySelector(`.matching-card[data-index="${second}"]`);
                        if (el1) el1.classList.remove('flipped');
                        if (el2) el2.classList.remove('flipped');

                        const instruction = document.getElementById('matching-instruction');
                        if (instruction) {
                            const messages = ['Try again!', 'Keep looking!', 'Almost!', 'Not quite!', 'So close!'];
                            instruction.textContent = randomFromArray(messages);
                        }

                        matchingState.flippedCards = [];
                        matchingState.locked = false;
                    }, 800));
                }
            }
        }

        function finishMatchingGame() {
            if (!matchingState) return;

            const instruction = document.getElementById('matching-instruction');
            if (instruction) {
                const moves = matchingState.moves;
                let message = 'üéâ You matched them all! ';
                if (moves <= 8) message += 'Amazing memory!';
                else if (moves <= 12) message += 'Great job!';
                else if (moves <= 18) message += 'Well done!';
                else message += 'You did it!';
                instruction.textContent = message;
                instruction.classList.add('highlight');
            }

            // Celebrate animation on all cards
            document.querySelectorAll('.matching-card.matched').forEach((card, i) => {
                setTimeout(() => {
                    card.classList.add('celebrating');
                }, i * 80);
            });

            matchingState._timeouts.push(setTimeout(() => endMatchingGame(), 2500));
        }

        function endMatchingGame() {
            if (matchingState && matchingState._handleEscape) {
                document.removeEventListener('keydown', matchingState._handleEscape);
            }
            if (matchingState && matchingState._timeouts) {
                matchingState._timeouts.forEach(id => clearTimeout(id));
            }

            const overlay = document.querySelector('.matching-game-overlay');
            if (overlay) overlay.remove();

            // Apply rewards based on performance
            if (matchingState && matchingState.matchesFound > 0 && gameState.pet) {
                const happinessBonus = Math.min(matchingState.matchesFound * 5, 30);
                const energyCost = Math.min(matchingState.moves, 10);

                gameState.pet.happiness = clamp(gameState.pet.happiness + happinessBonus, 0, 100);
                gameState.pet.energy = clamp(gameState.pet.energy - energyCost, 0, 100);

                const petData = PET_TYPES[gameState.pet.type];
                const feedback = document.getElementById('feedback');
                if (feedback) {
                    feedback.textContent = `${petData.emoji} Loved matching! (${matchingState.matchesFound} pairs found)`;
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 3000);
                }

                updateNeedDisplays();
                updatePetMood();
                saveGame();

                announce(`Matching Game over! ${matchingState.matchesFound} pairs found in ${matchingState.moves} moves! Happiness +${happinessBonus}!`);
            }

            matchingState = null;
        }

        // ==================== SIMON SAYS MINI-GAME ====================

        const SIMON_COLORS = ['green', 'red', 'yellow', 'blue'];
        const SIMON_ICONS = { green: 'üü¢', red: 'üî¥', yellow: 'üü°', blue: 'üîµ' };
        const SIMON_FREQUENCIES = { green: 392, red: 523.25, yellow: 659.25, blue: 783.99 };

        let simonState = null;
        let simonAudioCtx = null;

        function simonPlayTone(color, duration) {
            try {
                if (!simonAudioCtx) {
                    simonAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const osc = simonAudioCtx.createOscillator();
                const gain = simonAudioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = SIMON_FREQUENCIES[color];
                gain.gain.value = 0.3;
                gain.gain.exponentialRampToValueAtTime(0.001, simonAudioCtx.currentTime + duration / 1000);
                osc.connect(gain);
                gain.connect(simonAudioCtx.destination);
                osc.start();
                osc.stop(simonAudioCtx.currentTime + duration / 1000);
            } catch (e) {
                // Audio not supported ‚Äî game works visually without it
            }
        }

        function simonPlayErrorTone() {
            try {
                if (!simonAudioCtx) {
                    simonAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const osc = simonAudioCtx.createOscillator();
                const gain = simonAudioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 150;
                gain.gain.value = 0.25;
                gain.gain.exponentialRampToValueAtTime(0.001, simonAudioCtx.currentTime + 0.6);
                osc.connect(gain);
                gain.connect(simonAudioCtx.destination);
                osc.start();
                osc.stop(simonAudioCtx.currentTime + 0.6);
            } catch (e) {
                // Audio not supported
            }
        }

        function startSimonSaysGame() {
            if (!gameState.pet) return;

            const existing = document.querySelector('.simonsays-game-overlay');
            if (existing) existing.remove();

            simonState = {
                pattern: [],
                playerIndex: 0,
                round: 0,
                score: 0,
                highestRound: 0,
                phase: 'watching', // 'watching', 'playing', 'gameover'
                playbackIndex: 0,
                playbackTimer: null,
                active: true
            };

            renderSimonSaysGame();
            setTimeout(() => simonNextRound(), 800);

            announce('Simon Says! Watch the pattern, then repeat it!');
        }

        function renderSimonSaysGame() {
            const overlay = document.createElement('div');
            overlay.className = 'simonsays-game-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', 'Simon Says mini-game');

            const pet = gameState.pet;
            const mood = getMood(pet);
            const petSVG = generatePetSVG(pet, mood);

            overlay.innerHTML = `
                <div class="simonsays-game">
                    <h2 class="simonsays-game-title">üéµ Simon Says!</h2>
                    <p class="simonsays-game-score" id="simon-score" aria-live="polite">Score: 0</p>
                    <p class="simonsays-game-round" id="simon-round">Round: 1</p>
                    <div class="simonsays-board">
                        <div class="simonsays-pad-container">
                            <button class="simonsays-pad disabled" data-color="green" aria-label="Green pad"></button>
                            <button class="simonsays-pad disabled" data-color="red" aria-label="Red pad"></button>
                            <button class="simonsays-pad disabled" data-color="yellow" aria-label="Yellow pad"></button>
                            <button class="simonsays-pad disabled" data-color="blue" aria-label="Blue pad"></button>
                        </div>
                        <div class="simonsays-center">
                            <div class="simonsays-center-pet" id="simon-pet">${petSVG}</div>
                        </div>
                    </div>
                    <p class="simonsays-instruction watching" id="simon-instruction">Watch the pattern...</p>
                    <div class="simonsays-buttons">
                        <button class="simonsays-done-btn" id="simon-done" aria-label="Stop playing Simon Says">Done</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Pad click listeners
            overlay.querySelectorAll('.simonsays-pad').forEach(pad => {
                pad.addEventListener('click', () => {
                    if (!simonState || simonState.phase !== 'playing') return;
                    const color = pad.getAttribute('data-color');
                    simonHandleInput(color);
                });
            });

            // Done button
            overlay.querySelector('#simon-done').addEventListener('click', () => endSimonSaysGame());

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) endSimonSaysGame();
            });

            // Escape to close
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    endSimonSaysGame();
                }
            }
            document.addEventListener('keydown', handleEscape);
            simonState._handleEscape = handleEscape;

            // Focus done button
            overlay.querySelector('#simon-done').focus();
        }

        function simonNextRound() {
            if (!simonState || !simonState.active) return;

            simonState.round++;
            simonState.playerIndex = 0;
            simonState.phase = 'watching';

            // Add a new random color to the pattern
            const nextColor = SIMON_COLORS[Math.floor(Math.random() * SIMON_COLORS.length)];
            simonState.pattern.push(nextColor);

            // Update round display
            const roundEl = document.getElementById('simon-round');
            if (roundEl) roundEl.textContent = `Round: ${simonState.round}`;

            // Update instruction
            const instruction = document.getElementById('simon-instruction');
            if (instruction) {
                instruction.textContent = 'Watch the pattern...';
                instruction.className = 'simonsays-instruction watching';
            }

            // Disable pads during playback
            simonSetPadsDisabled(true);

            // Play the pattern
            simonState.playbackIndex = 0;
            const speed = Math.max(350, 600 - simonState.round * 25);

            setTimeout(() => simonPlayPattern(speed), 400);
        }

        function simonPlayPattern(speed) {
            if (!simonState || !simonState.active || simonState.phase !== 'watching') return;

            const idx = simonState.playbackIndex;
            if (idx >= simonState.pattern.length) {
                // Pattern playback done ‚Äî player's turn
                simonState.phase = 'playing';
                simonState.playerIndex = 0;
                simonSetPadsDisabled(false);

                const instruction = document.getElementById('simon-instruction');
                if (instruction) {
                    instruction.textContent = 'Your turn! Repeat the pattern!';
                    instruction.className = 'simonsays-instruction your-turn';
                }
                announce('Your turn! Repeat the pattern.');
                return;
            }

            const color = simonState.pattern[idx];
            simonLightPad(color, speed * 0.7);
            simonPlayTone(color, speed * 0.7);

            simonState.playbackIndex++;
            simonState.playbackTimer = setTimeout(() => simonPlayPattern(speed), speed);
        }

        function simonLightPad(color, duration) {
            const pad = document.querySelector(`.simonsays-pad[data-color="${color}"]`);
            if (!pad) return;

            pad.classList.add('lit');
            setTimeout(() => pad.classList.remove('lit'), duration);
        }

        function simonSetPadsDisabled(disabled) {
            document.querySelectorAll('.simonsays-pad').forEach(pad => {
                if (disabled) {
                    pad.classList.add('disabled');
                } else {
                    pad.classList.remove('disabled');
                }
            });
        }

        function simonHandleInput(color) {
            if (!simonState || simonState.phase !== 'playing') return;

            const expected = simonState.pattern[simonState.playerIndex];

            // Light the pad and play the tone regardless
            simonLightPad(color, 250);
            simonPlayTone(color, 250);

            if (color === expected) {
                // Correct!
                simonState.playerIndex++;
                simonState.score++;

                // Update score
                const scoreEl = document.getElementById('simon-score');
                if (scoreEl) scoreEl.textContent = `Score: ${simonState.score}`;

                // Pet bounces on correct input
                const petEl = document.getElementById('simon-pet');
                if (petEl) {
                    petEl.classList.add('bouncing');
                    setTimeout(() => petEl.classList.remove('bouncing'), 400);
                }

                // Check if player completed the full pattern
                if (simonState.playerIndex >= simonState.pattern.length) {
                    simonState.highestRound = simonState.round;
                    simonState.phase = 'watching';
                    simonSetPadsDisabled(true);

                    const instruction = document.getElementById('simon-instruction');
                    if (instruction) {
                        const messages = ['Great job!', 'Well done!', 'Awesome!', 'Perfect!', 'Amazing!', 'Super!'];
                        instruction.textContent = randomFromArray(messages);
                        instruction.className = 'simonsays-instruction highlight';
                    }

                    announce(`Round ${simonState.round} complete!`);

                    // Next round after a brief pause
                    setTimeout(() => simonNextRound(), 1000);
                }
            } else {
                // Wrong!
                simonState.phase = 'gameover';
                simonPlayErrorTone();
                simonSetPadsDisabled(true);

                // Flash all pads to indicate error
                document.querySelectorAll('.simonsays-pad').forEach(pad => {
                    pad.classList.add('lit');
                    setTimeout(() => pad.classList.remove('lit'), 500);
                });

                const instruction = document.getElementById('simon-instruction');
                if (instruction) {
                    const round = simonState.highestRound || (simonState.round - 1);
                    let message = `Oops! You reached round ${simonState.round}! `;
                    if (round >= 8) message += 'Incredible memory!';
                    else if (round >= 5) message += 'Great job!';
                    else if (round >= 3) message += 'Nice try!';
                    else message += 'Keep practicing!';
                    instruction.textContent = message;
                    instruction.className = 'simonsays-instruction wrong';
                }

                announce(`Game over! You reached round ${simonState.round}.`);

                // Auto-end after showing result
                setTimeout(() => endSimonSaysGame(), 2500);
            }
        }

        function endSimonSaysGame() {
            if (simonState && simonState.playbackTimer) clearTimeout(simonState.playbackTimer);

            if (simonState && simonState._handleEscape) {
                document.removeEventListener('keydown', simonState._handleEscape);
            }

            const overlay = document.querySelector('.simonsays-game-overlay');
            if (overlay) overlay.remove();

            // Apply rewards based on rounds completed
            if (simonState && simonState.score > 0 && gameState.pet) {
                const roundsCompleted = simonState.highestRound;
                const happinessBonus = Math.min(roundsCompleted * 4, 30);
                const energyCost = Math.min(roundsCompleted * 2, 10);

                gameState.pet.happiness = clamp(gameState.pet.happiness + happinessBonus, 0, 100);
                gameState.pet.energy = clamp(gameState.pet.energy - energyCost, 0, 100);

                const petData = PET_TYPES[gameState.pet.type];
                const feedback = document.getElementById('feedback');
                if (feedback) {
                    feedback.textContent = `${petData.emoji} Loved Simon Says! (Round ${simonState.highestRound})`;
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 3000);
                }

                updateNeedDisplays();
                updatePetMood();
                saveGame();

                announce(`Simon Says over! Reached round ${simonState.highestRound}! Happiness +${happinessBonus}!`);
            }

            // Clean up audio context
            if (simonAudioCtx) {
                try { simonAudioCtx.close(); } catch (e) {}
                simonAudioCtx = null;
            }

            simonState = null;
        }

        // ==================== COLORING MINI-GAME ====================

        const COLORING_PALETTE = [
            { name: 'Red', hex: '#FF4444' },
            { name: 'Orange', hex: '#FF9933' },
            { name: 'Yellow', hex: '#FFD700' },
            { name: 'Light Green', hex: '#8BC34A' },
            { name: 'Green', hex: '#4CAF50' },
            { name: 'Sky Blue', hex: '#64B5F6' },
            { name: 'Blue', hex: '#1E88E5' },
            { name: 'Purple', hex: '#9C27B0' },
            { name: 'Pink', hex: '#FF69B4' },
            { name: 'Brown', hex: '#795548' },
            { name: 'Tan', hex: '#D2B48C' },
            { name: 'White', hex: '#FFFFFF' }
        ];

        let coloringState = null;

        function startColoringGame() {
            if (!gameState.pet) return;

            const existing = document.querySelector('.coloring-game-overlay');
            if (existing) existing.remove();

            coloringState = {
                selectedColor: COLORING_PALETTE[0].hex,
                regionsColored: new Set(),
                totalRegions: 0
            };

            renderColoringGame();
            announce('Coloring time! Pick a color and tap parts of the picture to color them!');
        }

        function renderColoringGame() {
            const overlay = document.createElement('div');
            overlay.className = 'coloring-game-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', 'Coloring mini-game');

            const petType = gameState.pet.type;
            const scene = generateColoringScene(petType);

            let paletteHTML = '';
            COLORING_PALETTE.forEach((color) => {
                const selected = color.hex === coloringState.selectedColor ? 'selected' : '';
                paletteHTML += `<button class="coloring-swatch ${selected}"
                    data-color="${color.hex}"
                    aria-label="${color.name}"
                    style="background-color: ${color.hex}; ${color.hex === '#FFFFFF' ? 'border-color: #bbb;' : ''}"
                    title="${color.name}"></button>`;
            });

            overlay.innerHTML = `
                <div class="coloring-game">
                    <h2 class="coloring-game-title">üé® Coloring Time!</h2>
                    <p class="coloring-game-hint" id="coloring-hint">Pick a color, then tap to paint!</p>
                    <div class="coloring-canvas-wrap">
                        ${scene}
                    </div>
                    <div class="coloring-palette" role="toolbar" aria-label="Color palette">
                        ${paletteHTML}
                    </div>
                    <div class="coloring-buttons">
                        <button class="coloring-clear-btn" id="coloring-clear" aria-label="Clear all colors">Clear</button>
                        <button class="coloring-done-btn" id="coloring-done" aria-label="Finish coloring">Done</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Count total regions
            coloringState.totalRegions = overlay.querySelectorAll('.coloring-region').length;

            // Region click listeners
            overlay.querySelectorAll('.coloring-region').forEach(region => {
                region.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const regionId = region.getAttribute('data-region');
                    region.setAttribute('fill', coloringState.selectedColor);
                    region.style.fill = coloringState.selectedColor;
                    coloringState.regionsColored.add(regionId);

                    // Feedback flash
                    region.style.transition = 'none';
                    region.style.opacity = '0.7';
                    setTimeout(() => {
                        region.style.transition = 'opacity 0.2s';
                        region.style.opacity = '1';
                    }, 50);
                });

                region.addEventListener('mouseenter', () => {
                    region.style.cursor = 'pointer';
                    region.style.strokeWidth = '3';
                });
                region.addEventListener('mouseleave', () => {
                    region.style.strokeWidth = '2';
                });
            });

            // Palette click listeners
            overlay.querySelectorAll('.coloring-swatch').forEach(swatch => {
                swatch.addEventListener('click', () => {
                    coloringState.selectedColor = swatch.getAttribute('data-color');
                    overlay.querySelectorAll('.coloring-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                });
            });

            // Clear button
            overlay.querySelector('#coloring-clear').addEventListener('click', () => {
                overlay.querySelectorAll('.coloring-region').forEach(region => {
                    region.setAttribute('fill', '#F5F5F5');
                    region.style.fill = '#F5F5F5';
                });
                coloringState.regionsColored.clear();
                announce('Colors cleared!');
            });

            // Done button
            overlay.querySelector('#coloring-done').addEventListener('click', () => endColoringGame());

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) endColoringGame();
            });

            // Escape to close
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    endColoringGame();
                }
            }
            document.addEventListener('keydown', handleEscape);
            coloringState._handleEscape = handleEscape;

            // Focus done button
            overlay.querySelector('#coloring-done').focus();
        }

        function generateColoringScene(petType) {
            const petParts = getColoringPetParts(petType);

            let petPartsHTML = '';
            petParts.forEach(part => {
                petPartsHTML += part;
            });

            return `
                <svg class="coloring-scene" viewBox="0 0 300 360" xmlns="http://www.w3.org/2000/svg">
                    <!-- Sky -->
                    <rect class="coloring-region" data-region="sky" x="0" y="0" width="300" height="230" fill="#F5F5F5" stroke="#555" stroke-width="2"/>
                    <!-- Ground -->
                    <rect class="coloring-region" data-region="ground" x="0" y="230" width="300" height="130" fill="#F5F5F5" stroke="#555" stroke-width="2"/>

                    <!-- Sun -->
                    <circle class="coloring-region" data-region="sun" cx="255" cy="50" r="28" fill="#F5F5F5" stroke="#333" stroke-width="2"/>
                    <!-- Sun rays -->
                    <g stroke="#333" stroke-width="1.5" stroke-linecap="round">
                        <line x1="255" y1="15" x2="255" y2="8"/>
                        <line x1="255" y1="85" x2="255" y2="92"/>
                        <line x1="220" y1="50" x2="213" y2="50"/>
                        <line x1="290" y1="50" x2="297" y2="50"/>
                        <line x1="230" y1="25" x2="225" y2="20"/>
                        <line x1="280" y1="25" x2="285" y2="20"/>
                        <line x1="230" y1="75" x2="225" y2="80"/>
                        <line x1="280" y1="75" x2="285" y2="80"/>
                    </g>

                    <!-- Cloud -->
                    <path class="coloring-region" data-region="cloud" d="M40 70 Q50 40 75 55 Q85 30 110 48 Q125 35 138 58 Q140 75 110 78 Q80 80 50 78 Z" fill="#F5F5F5" stroke="#333" stroke-width="2"/>

                    <!-- Tree trunk -->
                    <rect class="coloring-region" data-region="trunk" x="32" y="175" width="22" height="60" rx="3" fill="#F5F5F5" stroke="#333" stroke-width="2"/>
                    <!-- Tree canopy -->
                    <ellipse class="coloring-region" data-region="leaves" cx="43" cy="160" rx="38" ry="35" fill="#F5F5F5" stroke="#333" stroke-width="2"/>

                    <!-- Flower 1 -->
                    <rect class="coloring-region" data-region="stem1" x="98" y="305" width="4" height="25" fill="#F5F5F5" stroke="#333" stroke-width="1.5"/>
                    <circle class="coloring-region" data-region="flower1" cx="100" cy="298" r="12" fill="#F5F5F5" stroke="#333" stroke-width="2"/>
                    <circle class="coloring-region" data-region="flower1center" cx="100" cy="298" r="4" fill="#F5F5F5" stroke="#333" stroke-width="1.5"/>

                    <!-- Flower 2 -->
                    <rect class="coloring-region" data-region="stem2" x="228" y="310" width="4" height="25" fill="#F5F5F5" stroke="#333" stroke-width="1.5"/>
                    <circle class="coloring-region" data-region="flower2" cx="230" cy="303" r="12" fill="#F5F5F5" stroke="#333" stroke-width="2"/>
                    <circle class="coloring-region" data-region="flower2center" cx="230" cy="303" r="4" fill="#F5F5F5" stroke="#333" stroke-width="1.5"/>

                    <!-- Grass blades -->
                    <g stroke="#333" stroke-width="1" stroke-linecap="round" fill="none">
                        <path d="M15 233 Q18 220 20 233"/>
                        <path d="M55 232 Q58 218 61 232"/>
                        <path d="M135 233 Q138 222 141 233"/>
                        <path d="M195 232 Q198 220 201 232"/>
                        <path d="M265 233 Q268 221 271 233"/>
                    </g>

                    <!-- Pet -->
                    <g class="coloring-pet-group">
                        ${petPartsHTML}
                    </g>

                    <!-- Pet face details -->
                    ${getColoringPetFace(petType)}
                </svg>
            `;
        }

        function getColoringPetParts(petType) {
            const cx = 175, cy = 270;

            switch (petType) {
                case 'dog':
                    return [
                        `<ellipse class="coloring-region" data-region="pet-body" cx="${cx}" cy="${cy+15}" rx="38" ry="30" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<path class="coloring-region" data-region="pet-tail" d="M${cx+35} ${cy+10} Q${cx+55} ${cy-15} ${cx+50} ${cy-25}" fill="none" stroke="#333" stroke-width="8" stroke-linecap="round"/>`,
                        `<circle class="coloring-region" data-region="pet-head" cx="${cx}" cy="${cy-25}" r="28" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<ellipse class="coloring-region" data-region="pet-ear-left" cx="${cx-22}" cy="${cy-45}" rx="10" ry="18" fill="#F5F5F5" stroke="#333" stroke-width="2" transform="rotate(-15 ${cx-22} ${cy-45})"/>`,
                        `<ellipse class="coloring-region" data-region="pet-ear-right" cx="${cx+22}" cy="${cy-45}" rx="10" ry="18" fill="#F5F5F5" stroke="#333" stroke-width="2" transform="rotate(15 ${cx+22} ${cy-45})"/>`,
                        `<ellipse class="coloring-region" data-region="pet-snout" cx="${cx}" cy="${cy-17}" rx="13" ry="10" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                    ];
                case 'cat':
                    return [
                        `<ellipse class="coloring-region" data-region="pet-body" cx="${cx}" cy="${cy+15}" rx="35" ry="28" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<path class="coloring-region" data-region="pet-tail" d="M${cx+32} ${cy+20} Q${cx+60} ${cy+5} ${cx+50} ${cy-15} Q${cx+42} ${cy-30} ${cx+55} ${cy-35}" fill="none" stroke="#333" stroke-width="7" stroke-linecap="round"/>`,
                        `<circle class="coloring-region" data-region="pet-head" cx="${cx}" cy="${cy-25}" r="26" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<polygon class="coloring-region" data-region="pet-ear-left" points="${cx-25},${cy-38} ${cx-12},${cy-60} ${cx-5},${cy-38}" fill="#F5F5F5" stroke="#333" stroke-width="2" stroke-linejoin="round"/>`,
                        `<polygon class="coloring-region" data-region="pet-ear-right" points="${cx+5},${cy-38} ${cx+12},${cy-60} ${cx+25},${cy-38}" fill="#F5F5F5" stroke="#333" stroke-width="2" stroke-linejoin="round"/>`,
                    ];
                case 'bunny':
                    return [
                        `<ellipse class="coloring-region" data-region="pet-body" cx="${cx}" cy="${cy+15}" rx="33" ry="28" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<circle class="coloring-region" data-region="pet-tail" cx="${cx+30}" cy="${cy+25}" r="10" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<circle class="coloring-region" data-region="pet-head" cx="${cx}" cy="${cy-22}" r="26" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<ellipse class="coloring-region" data-region="pet-ear-left" cx="${cx-12}" cy="${cy-65}" rx="9" ry="28" fill="#F5F5F5" stroke="#333" stroke-width="2" transform="rotate(-8 ${cx-12} ${cy-65})"/>`,
                        `<ellipse class="coloring-region" data-region="pet-ear-right" cx="${cx+12}" cy="${cy-65}" rx="9" ry="28" fill="#F5F5F5" stroke="#333" stroke-width="2" transform="rotate(8 ${cx+12} ${cy-65})"/>`,
                        `<ellipse class="coloring-region" data-region="pet-inner-ear-left" cx="${cx-12}" cy="${cy-65}" rx="5" ry="20" fill="#F5F5F5" stroke="#333" stroke-width="1.5" transform="rotate(-8 ${cx-12} ${cy-65})"/>`,
                        `<ellipse class="coloring-region" data-region="pet-inner-ear-right" cx="${cx+12}" cy="${cy-65}" rx="5" ry="20" fill="#F5F5F5" stroke="#333" stroke-width="1.5" transform="rotate(8 ${cx+12} ${cy-65})"/>`,
                    ];
                case 'bird':
                    return [
                        `<ellipse class="coloring-region" data-region="pet-body" cx="${cx}" cy="${cy+10}" rx="30" ry="25" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<path class="coloring-region" data-region="pet-wing-left" d="M${cx-28} ${cy+5} Q${cx-55} ${cy-5} ${cx-45} ${cy+25} Q${cx-35} ${cy+30} ${cx-25} ${cy+20} Z" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<path class="coloring-region" data-region="pet-wing-right" d="M${cx+28} ${cy+5} Q${cx+55} ${cy-5} ${cx+45} ${cy+25} Q${cx+35} ${cy+30} ${cx+25} ${cy+20} Z" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<path class="coloring-region" data-region="pet-tail-feathers" d="M${cx-5} ${cy+33} L${cx-15} ${cy+55} L${cx} ${cy+48} L${cx+15} ${cy+55} L${cx+5} ${cy+33} Z" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<ellipse class="coloring-region" data-region="pet-belly" cx="${cx}" cy="${cy+12}" rx="18" ry="16" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<circle class="coloring-region" data-region="pet-head" cx="${cx}" cy="${cy-22}" r="22" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                    ];
                case 'hamster':
                    return [
                        `<ellipse class="coloring-region" data-region="pet-body" cx="${cx}" cy="${cy+12}" rx="35" ry="30" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<circle class="coloring-region" data-region="pet-head" cx="${cx}" cy="${cy-20}" r="28" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<circle class="coloring-region" data-region="pet-ear-left" cx="${cx-24}" cy="${cy-42}" r="10" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<circle class="coloring-region" data-region="pet-ear-right" cx="${cx+24}" cy="${cy-42}" r="10" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<ellipse class="coloring-region" data-region="pet-cheek-left" cx="${cx-20}" cy="${cy-12}" rx="10" ry="8" fill="#F5F5F5" stroke="#333" stroke-width="1.5"/>`,
                        `<ellipse class="coloring-region" data-region="pet-cheek-right" cx="${cx+20}" cy="${cy-12}" rx="10" ry="8" fill="#F5F5F5" stroke="#333" stroke-width="1.5"/>`,
                    ];
                case 'turtle':
                    return [
                        `<ellipse class="coloring-region" data-region="pet-leg-left" cx="${cx-30}" cy="${cy+35}" rx="10" ry="8" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<ellipse class="coloring-region" data-region="pet-leg-right" cx="${cx+30}" cy="${cy+35}" rx="10" ry="8" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<path class="coloring-region" data-region="pet-tail" d="M${cx+43} ${cy+15} L${cx+58} ${cy+20} L${cx+45} ${cy+22} Z" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                        `<ellipse class="coloring-region" data-region="pet-shell" cx="${cx}" cy="${cy+5}" rx="45" ry="35" fill="#F5F5F5" stroke="#333" stroke-width="2.5"/>`,
                        `<ellipse class="coloring-region" data-region="pet-shell-inner" cx="${cx}" cy="${cy+5}" rx="30" ry="22" fill="#F5F5F5" stroke="#333" stroke-width="1.5"/>`,
                        `<circle class="coloring-region" data-region="pet-head" cx="${cx-38}" cy="${cy-5}" r="18" fill="#F5F5F5" stroke="#333" stroke-width="2"/>`,
                    ];
                default:
                    return getColoringPetParts('dog');
            }
        }

        function getColoringPetFace(petType) {
            const cx = 175, cy = 270;

            switch (petType) {
                case 'dog':
                    return `
                        <circle cx="${cx-10}" cy="${cy-30}" r="4" fill="#333"/>
                        <circle cx="${cx+10}" cy="${cy-30}" r="4" fill="#333"/>
                        <circle cx="${cx-9}" cy="${cy-31}" r="1.5" fill="white"/>
                        <circle cx="${cx+11}" cy="${cy-31}" r="1.5" fill="white"/>
                        <ellipse cx="${cx}" cy="${cy-20}" rx="5" ry="4" fill="#333"/>
                        <path d="M${cx-8} ${cy-13} Q${cx} ${cy-6} ${cx+8} ${cy-13}" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                    `;
                case 'cat':
                    return `
                        <ellipse cx="${cx-9}" cy="${cy-28}" rx="4" ry="5" fill="#333"/>
                        <ellipse cx="${cx+9}" cy="${cy-28}" rx="4" ry="5" fill="#333"/>
                        <ellipse cx="${cx-8}" cy="${cy-28}" rx="2" ry="3" fill="#7CCC70"/>
                        <ellipse cx="${cx+10}" cy="${cy-28}" rx="2" ry="3" fill="#7CCC70"/>
                        <polygon points="${cx},${cy-19} ${cx-4},${cy-15} ${cx+4},${cy-15}" fill="#FFB6C1"/>
                        <g stroke="#333" stroke-width="1" stroke-linecap="round">
                            <line x1="${cx-25}" y1="${cy-18}" x2="${cx-10}" y2="${cy-16}"/>
                            <line x1="${cx-23}" y1="${cy-12}" x2="${cx-10}" y2="${cy-13}"/>
                            <line x1="${cx+25}" y1="${cy-18}" x2="${cx+10}" y2="${cy-16}"/>
                            <line x1="${cx+23}" y1="${cy-12}" x2="${cx+10}" y2="${cy-13}"/>
                        </g>
                        <path d="M${cx} ${cy-15} L${cx-5} ${cy-10}" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                        <path d="M${cx} ${cy-15} L${cx+5} ${cy-10}" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                    `;
                case 'bunny':
                    return `
                        <circle cx="${cx-9}" cy="${cy-26}" r="4" fill="#333"/>
                        <circle cx="${cx+9}" cy="${cy-26}" r="4" fill="#333"/>
                        <circle cx="${cx-8}" cy="${cy-27}" r="1.5" fill="white"/>
                        <circle cx="${cx+10}" cy="${cy-27}" r="1.5" fill="white"/>
                        <ellipse cx="${cx}" cy="${cy-18}" rx="4" ry="3" fill="#FFB6C1"/>
                        <path d="M${cx} ${cy-15} L${cx-4} ${cy-11}" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                        <path d="M${cx} ${cy-15} L${cx+4} ${cy-11}" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                        <rect x="${cx-3}" y="${cy-15}" width="3" height="4" rx="1" fill="white" stroke="#333" stroke-width="1"/>
                        <rect x="${cx}" y="${cy-15}" width="3" height="4" rx="1" fill="white" stroke="#333" stroke-width="1"/>
                    `;
                case 'bird':
                    return `
                        <circle cx="${cx-8}" cy="${cy-26}" r="3.5" fill="#333"/>
                        <circle cx="${cx+8}" cy="${cy-26}" r="3.5" fill="#333"/>
                        <circle cx="${cx-7}" cy="${cy-27}" r="1.3" fill="white"/>
                        <circle cx="${cx+9}" cy="${cy-27}" r="1.3" fill="white"/>
                        <polygon points="${cx},${cy-18} ${cx-6},${cy-13} ${cx+6},${cy-13}" fill="#FF9800" stroke="#333" stroke-width="1.5"/>
                    `;
                case 'hamster':
                    return `
                        <circle cx="${cx-10}" cy="${cy-24}" r="4.5" fill="#333"/>
                        <circle cx="${cx+10}" cy="${cy-24}" r="4.5" fill="#333"/>
                        <circle cx="${cx-9}" cy="${cy-25}" r="2" fill="white"/>
                        <circle cx="${cx+11}" cy="${cy-25}" r="2" fill="white"/>
                        <circle cx="${cx}" cy="${cy-16}" r="3" fill="#FFB6C1"/>
                        <path d="M${cx-5} ${cy-12} Q${cx} ${cy-7} ${cx+5} ${cy-12}" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                    `;
                case 'turtle':
                    return `
                        <circle cx="${cx-43}" cy="${cy-10}" r="3" fill="#333"/>
                        <circle cx="${cx-44}" cy="${cy-11}" r="1.2" fill="white"/>
                        <path d="M${cx-48} ${cy} Q${cx-38} ${cy+4} ${cx-33} ${cy}" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                        <line x1="${cx-10}" y1="${cy-15}" x2="${cx-10}" y2="${cy+25}" stroke="#333" stroke-width="1"/>
                        <line x1="${cx+10}" y1="${cy-15}" x2="${cx+10}" y2="${cy+25}" stroke="#333" stroke-width="1"/>
                        <line x1="${cx-30}" y1="${cy+5}" x2="${cx+30}" y2="${cy+5}" stroke="#333" stroke-width="1"/>
                    `;
                default:
                    return getColoringPetFace('dog');
            }
        }

        function endColoringGame() {
            if (coloringState && coloringState._handleEscape) {
                document.removeEventListener('keydown', coloringState._handleEscape);
            }

            const overlay = document.querySelector('.coloring-game-overlay');
            if (overlay) overlay.remove();

            // Apply rewards based on regions colored
            if (coloringState && coloringState.regionsColored.size > 0 && gameState.pet) {
                const colored = coloringState.regionsColored.size;
                const total = coloringState.totalRegions;
                const ratio = colored / Math.max(total, 1);

                const happinessBonus = Math.min(Math.round(ratio * 30), 30);
                const energyCost = Math.min(Math.round(ratio * 8), 10);

                gameState.pet.happiness = clamp(gameState.pet.happiness + happinessBonus, 0, 100);
                gameState.pet.energy = clamp(gameState.pet.energy - energyCost, 0, 100);

                const petData = PET_TYPES[gameState.pet.type];
                const feedback = document.getElementById('feedback');
                if (feedback) {
                    const messages = ['Beautiful art!', 'So colorful!', 'What a masterpiece!', 'Pretty!', 'Amazing colors!'];
                    feedback.textContent = `${petData.emoji} ${randomFromArray(messages)}`;
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 3000);
                }

                updateNeedDisplays();
                updatePetMood();
                saveGame();

                announce(`Coloring done! You colored ${colored} parts! Happiness +${happinessBonus}!`);
            }

            coloringState = null;
        }

        // ==================== DECAY TIMER ====================

        let decayInterval = null;
        let lastDecayAnnouncement = 0;

        function startDecayTimer() {
            if (decayInterval) clearInterval(decayInterval);

            // Decrease needs every 30 seconds (gentle for young children)
            decayInterval = setInterval(() => {
                if (gameState.phase === 'pet' && gameState.pet && !document.hidden) {
                    const pet = gameState.pet;
                    const weather = gameState.weather || 'sunny';
                    const weatherData = WEATHER_TYPES[weather];
                    const room = ROOMS[gameState.currentRoom || 'bedroom'];
                    const isOutdoor = room ? room.isOutdoor : false;

                    // Day/Night cycle energy modifiers
                    const timeOfDay = gameState.timeOfDay || 'day';
                    let energyDecayBonus = 0;
                    let energyRegenBonus = 0;
                    if (timeOfDay === 'night') {
                        energyDecayBonus = 2; // Energy drains faster at night (pet gets sleepy)
                    } else if (timeOfDay === 'sunset') {
                        energyDecayBonus = 1; // Energy starts draining more at sunset
                    } else if (timeOfDay === 'sunrise') {
                        energyRegenBonus = 1; // Energy recovers slightly in the morning
                    }

                    // Base decay
                    pet.hunger = clamp(pet.hunger - 1, 0, 100);
                    pet.cleanliness = clamp(pet.cleanliness - 1, 0, 100);
                    pet.happiness = clamp(pet.happiness - 1, 0, 100);
                    pet.energy = clamp(pet.energy - 1 - energyDecayBonus + energyRegenBonus, 0, 100);

                    // Extra weather-based decay when outdoors
                    if (isOutdoor) {
                        pet.happiness = clamp(pet.happiness - weatherData.happinessDecayModifier, 0, 100);
                        pet.energy = clamp(pet.energy - weatherData.energyDecayModifier, 0, 100);
                        pet.cleanliness = clamp(pet.cleanliness - weatherData.cleanlinessDecayModifier, 0, 100);
                    }

                    // Check for weather changes
                    checkWeatherChange();

                    // Update time of day and refresh display if changed
                    const newTimeOfDay = getTimeOfDay();
                    if (gameState.timeOfDay !== newTimeOfDay) {
                        const previousTime = gameState.timeOfDay;
                        gameState.timeOfDay = newTimeOfDay;
                        updateDayNightDisplay();

                        // Morning energy boost when transitioning to sunrise
                        if (newTimeOfDay === 'sunrise' && previousTime === 'night') {
                            pet.energy = clamp(pet.energy + 15, 0, 100);
                            announce(`Good morning! ${pet.name || PET_TYPES[pet.type].name} wakes up feeling refreshed!`);
                        }
                        // Nighttime sleepiness notification
                        if (newTimeOfDay === 'night') {
                            announce(`It's getting late! ${pet.name || PET_TYPES[pet.type].name} is getting sleepy...`);
                        }
                        // Sunset wind-down notification
                        if (newTimeOfDay === 'sunset') {
                            announce(`The sun is setting. ${pet.name || PET_TYPES[pet.type].name} is starting to wind down.`);
                        }
                    }

                    updateNeedDisplays();
                    updatePetMood();
                    saveGame();

                    // Gentle reminders at low levels (no negative messages)
                    // But don't spam - only announce every 2 minutes max
                    const now = Date.now();
                    if (now - lastDecayAnnouncement > 120000) {
                        const mood = getMood(pet);
                        if (mood === 'sad') {
                            const lowestNeed = Math.min(pet.hunger, pet.cleanliness, pet.happiness, pet.energy);
                            if (lowestNeed <= 20) {
                                let needName = '';
                                if (pet.hunger === lowestNeed) needName = 'hungry';
                                else if (pet.cleanliness === lowestNeed) needName = 'needs a bath';
                                else if (pet.energy === lowestNeed) needName = 'tired and needs sleep';
                                else needName = 'wants to play';
                                announce(`Your pet is ${needName}! Can you help?`);
                                lastDecayAnnouncement = now;
                            }
                        }
                    }
                }
            }, 30000); // Every 30 seconds
        }

        function updateDayNightDisplay() {
            const petArea = document.querySelector('.pet-area');
            if (!petArea) return;

            const timeOfDay = gameState.timeOfDay;
            const timeClass = timeOfDay === 'day' ? 'daytime' : timeOfDay === 'night' ? 'nighttime' : timeOfDay;
            const currentRoom = gameState.currentRoom || 'bedroom';
            const room = ROOMS[currentRoom];
            const isOutdoor = room ? room.isOutdoor : false;

            // Update class
            petArea.classList.remove('daytime', 'nighttime', 'sunset', 'sunrise');
            petArea.classList.add(timeClass);

            // Update room background for new time of day
            petArea.style.background = getRoomBackground(currentRoom, timeOfDay);

            // Update time indicator
            const timeIndicator = petArea.querySelector('.time-indicator');
            if (timeIndicator) {
                timeIndicator.textContent = getTimeIcon(timeOfDay);
                timeIndicator.setAttribute('aria-label', `Time: ${timeOfDay}`);
            }

            // Update room decor for time of day
            const decor = petArea.querySelector('.room-decor');
            if (decor) {
                decor.textContent = getRoomDecor(currentRoom, timeOfDay);
            }

            // Update celestial elements - remove all existing ones first
            const existingStars = petArea.querySelector('.stars-overlay');
            const existingMoon = petArea.querySelector('.moon');
            const existingSun = petArea.querySelector('.sun');
            petArea.querySelectorAll('.cloud').forEach(c => c.remove());

            if (existingStars) existingStars.remove();
            if (existingMoon) existingMoon.remove();
            if (existingSun) existingSun.remove();

            // Only add celestial elements for outdoor rooms
            if (isOutdoor) {
                if (timeOfDay === 'night') {
                    const starsOverlay = document.createElement('div');
                    starsOverlay.className = 'stars-overlay';
                    starsOverlay.innerHTML = generateStarsHTML();
                    petArea.insertBefore(starsOverlay, petArea.firstChild);

                    const moon = document.createElement('div');
                    moon.className = 'moon';
                    petArea.insertBefore(moon, petArea.children[1]);
                } else if (timeOfDay === 'day') {
                    const sun = document.createElement('div');
                    sun.className = 'sun';
                    petArea.insertBefore(sun, petArea.firstChild);

                    const cloud1 = document.createElement('div');
                    cloud1.className = 'cloud';
                    cloud1.style.cssText = 'top:12px;left:-30px;';
                    cloud1.textContent = '‚òÅÔ∏è';
                    petArea.appendChild(cloud1);

                    const cloud2 = document.createElement('div');
                    cloud2.className = 'cloud';
                    cloud2.style.cssText = 'top:35px;left:20%;';
                    cloud2.textContent = '‚òÅÔ∏è';
                    petArea.appendChild(cloud2);
                } else if (timeOfDay === 'sunrise' || timeOfDay === 'sunset') {
                    const cloud = document.createElement('div');
                    cloud.className = 'cloud';
                    cloud.style.cssText = 'top:18px;left:10%;';
                    cloud.textContent = '‚òÅÔ∏è';
                    petArea.appendChild(cloud);
                }
            }

            // Update weather visuals
            updateWeatherDisplay();
        }

        function updateWeatherDisplay() {
            const petArea = document.querySelector('.pet-area');
            if (!petArea) return;

            const weather = gameState.weather || 'sunny';
            const weatherData = WEATHER_TYPES[weather];
            const currentRoom = gameState.currentRoom || 'bedroom';
            const room = ROOMS[currentRoom];
            const isOutdoor = room ? room.isOutdoor : false;

            // Remove old weather overlay
            const oldOverlay = petArea.querySelector('.weather-overlay');
            if (oldOverlay) oldOverlay.remove();

            // Remove old weather classes
            petArea.classList.remove('weather-rainy', 'weather-snowy');

            // Add new weather effects for outdoor rooms
            if (isOutdoor && weather !== 'sunny') {
                petArea.classList.add(`weather-${weather}`);
                const weatherEl = document.createElement('div');
                weatherEl.innerHTML = generateWeatherHTML(weather);
                const overlay = weatherEl.firstChild;
                if (overlay) petArea.appendChild(overlay);
            }

            // Update weather badge
            const oldBadge = petArea.querySelector('.weather-badge');
            if (oldBadge) {
                oldBadge.className = `weather-badge ${weather}`;
                oldBadge.setAttribute('aria-label', `Weather: ${weatherData.name}`);
                oldBadge.innerHTML = `${weatherData.icon} ${weatherData.name}`;
            }
        }

        function stopDecayTimer() {
            if (decayInterval) {
                clearInterval(decayInterval);
                decayInterval = null;
            }
        }

        // ==================== VISIBILITY HANDLING ====================

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, save current state
                saveGame();
            } else {
                // Page is visible again, apply any decay that occurred while away
                if (gameState.phase === 'pet' && gameState.pet) {
                    const saved = loadGame();
                    if (saved && saved.pet) {
                        gameState.pet.hunger = saved.pet.hunger;
                        gameState.pet.cleanliness = saved.pet.cleanliness;
                        gameState.pet.happiness = saved.pet.happiness;
                        gameState.pet.energy = saved.pet.energy;
                        updateNeedDisplays();
                        updatePetMood();
                    }
                }
            }
        });

        // ==================== MODAL ====================

        function showModal(title, message, icon, onConfirm, onCancel) {
            // Remove any existing modal
            const existingModal = document.querySelector('.modal-overlay');
            if (existingModal) existingModal.remove();

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'modal-title');

            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-icon" aria-hidden="true">${icon}</div>
                    <h2 class="modal-title" id="modal-title">${title}</h2>
                    <p class="modal-message">${message}</p>
                    <div class="modal-buttons">
                        <button class="modal-btn cancel" id="modal-cancel">
                            No, Keep Pet
                        </button>
                        <button class="modal-btn confirm" id="modal-confirm">
                            Yes, New Egg
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            const confirmBtn = document.getElementById('modal-confirm');
            const cancelBtn = document.getElementById('modal-cancel');

            // Focus the cancel button (safer option for children)
            cancelBtn.focus();

            // Handle Escape key
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    closeModal();
                    if (onCancel) onCancel();
                }
            }
            document.addEventListener('keydown', handleEscape);

            function closeModal() {
                document.removeEventListener('keydown', handleEscape);
                modal.remove();
            }

            confirmBtn.addEventListener('click', () => {
                closeModal();
                if (onConfirm) onConfirm();
            });

            cancelBtn.addEventListener('click', () => {
                closeModal();
                if (onCancel) onCancel();
            });

            // Close on overlay click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                    if (onCancel) onCancel();
                }
            });

            // Trap focus within modal
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    const focusable = modal.querySelectorAll('button');
                    const first = focusable[0];
                    const last = focusable[focusable.length - 1];

                    if (e.shiftKey && document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    } else if (!e.shiftKey && document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            });

            announce(title + '. ' + message);
        }

        // ==================== MINI-GAME CLEANUP ====================

        function cleanupAllMiniGames() {
            if (fetchState) endFetchGame();
            if (hideSeekState) endHideSeekGame();
            if (bubblePopState) endBubblePopGame();
            if (matchingState) endMatchingGame();
            if (simonState) endSimonSaysGame();
            if (coloringState) endColoringGame();
        }

        // ==================== NEW PET ====================

        function startNewPet() {
            showModal(
                'New Pet?',
                'Say bye-bye to your pet and get a new egg?',
                'ü•ö',
                () => {
                    // Clean up any active mini-games
                    cleanupAllMiniGames();

                    // Clear the decay timer
                    if (decayInterval) {
                        clearInterval(decayInterval);
                        decayInterval = null;
                    }

                    // Stop weather timer
                    stopWeatherTimer();

                    gameState = {
                        phase: 'egg',
                        pet: null,
                        eggTaps: 0,
                        lastUpdate: Date.now(),
                        timeOfDay: getTimeOfDay(),
                        currentRoom: 'bedroom',
                        weather: getRandomWeather(),
                        lastWeatherChange: Date.now()
                    };
                    saveGame();
                    announce('Starting fresh with a new egg!', true);
                    renderEggPhase();
                },
                () => {
                    // User cancelled, focus back on the new pet button
                    const newPetBtn = document.getElementById('new-pet-btn');
                    if (newPetBtn) newPetBtn.focus();
                }
            );
        }

        // ==================== INITIALIZATION ====================

        function init() {
            // Stop any existing timers
            stopDecayTimer();
            stopWeatherTimer();

            const saved = loadGame();
            if (saved) {
                gameState = saved;
            }

            // Ensure weather state exists
            if (!gameState.weather || !WEATHER_TYPES[gameState.weather]) {
                gameState.weather = 'sunny';
            }
            if (!gameState.lastWeatherChange) {
                gameState.lastWeatherChange = Date.now();
            }

            if (gameState.phase === 'pet' && gameState.pet) {
                renderPetPhase();
                const petData = PET_TYPES[gameState.pet.type];
                const mood = getMood(gameState.pet);
                const weatherData = WEATHER_TYPES[gameState.weather];
                const moodGreeting = mood === 'happy' ? 'is so happy to see you!' :
                                     mood === 'sad' ? 'missed you and needs some care!' :
                                     'is glad you\'re back!';
                announce(`Welcome back! Your ${petData.name} ${moodGreeting} The weather is ${weatherData.name.toLowerCase()}.`);
            } else {
                // Reset to egg phase if not in pet phase
                gameState.phase = 'egg';
                gameState.eggTaps = gameState.eggTaps || 0;
                renderEggPhase();
                announce('Welcome to Pet Care Buddy! Tap the egg to hatch your new pet!');
            }
        }

        // Start the game when page loads
        document.addEventListener('DOMContentLoaded', init);

        // Save and cleanup on page unload
        window.addEventListener('beforeunload', () => {
            saveGame();
            stopDecayTimer();
            stopWeatherTimer();
        });

        // Also handle page hide for mobile browsers
        window.addEventListener('pagehide', () => {
            saveGame();
        });
    </script>
</body>
</html>
